# 并发程序中的错误

处理并发程序中的错误，相比处理顺序程序中的错误，涉及到完全不同的的思维方式。在本章中，我们将以咱们在 [第 6 章 “顺序程序中的错误处理”](../part-ii/Ch06-error_handling_in_sequential_programs.md) 中，了解的原则为基础，将那些思路扩展到并发程序。


我们将探讨错误处理的底层逻辑，以及错误如何在进程间传播，及被其他进程捕获的细节。最后，我们将以一些构成容错软件编程基础的小示例，结束本章。


请设想某个只有一个顺序进程的系统。当这个进程死亡时，我们就可能会陷入大麻烦，因为没有可以帮忙的别的进程。出于这个理由，顺序语言将重点放在失效的预防，及强调 *防御性编程* 上。


在 Erlang 中，我们有咱们可以调遣的大量进程，因此任何单个进程的失效，都不那么重要。通常我们只要编写少量防御性代码，而专注于编写 *纠正式代码*。我们会采取一些检测错误的手段，然后在错误发生后纠正他们。


> *知识点*：

- defensive programming
- corrective code


## 错误处理的哲学


并发 Erlang 程序中的错误处理，基于 *远端的错误检测及处理* 的这一思想。与其在发生错误的进程中处理该错误，我们会让该进程死亡，然后在另一进程中纠正该错误。

当我们要设计某个容错系统时，我们会假设错误会发生，进程会崩溃，机器会失效。我们的工作是在错误发生后，发现他们并尽可能纠正他们。在被错误被修正期间，系统用户不应注意到任何故障，或遭受任何的服务损失。

由于我们专注于治愈而非预防，我们的系统只有很少防御代码；相反，我们有在错误发生后，清理系统的代码。这意味着我们将专注于如何检测错误，如何识别出什么问题，以及如何使系统处于稳定状态。


检测错误及找出某处为何失效，是构建在 Erlang 虚拟机非常底层的功能，也属于 Erlang 这门编程语言的一部分。在标准 OTP 库中，提供了构建可以互相观察，并在检测到错误时采取纠正措施进程组的功能特性，[23.5 小节，*监督树*](#监督树) 中对此进行了描述。本章是关于这门语言在错误检测和恢复的各个方面。

Erlang 构建容错软件的哲学，可概括为两个容易记住的短语：“让别的进程修复错误” 和 “让其崩溃”。



### 让别的进程修复错误


安排了互相监控健康状况的一些进程。当某个进程死亡时，某个别的进程可观察到这一情况，并执行纠正措施。


要让一个进程观察另一进程，我们必须在这两个进程间，建立 *链接* 或 *监控*。当被链接或受监控的进程死亡时，则观察进程会被告知。


观察进程会跨越机器边界透明地运行，因此运行在一台机器上的进程，可以监控某个运行在另一机器上进程的行为。这是编程容错系统的基础。我们无法在一台机器上构造容错系统，因为整台机器可能崩溃，所以我们需要至少两台机器。一台机器执行计算，另一机器观察第一台机器，并在第一台机器崩溃时接管。


这可看作是对顺序代码中错误处理的扩展。毕竟，我们可捕获顺序代码中的异常，并尝试纠正错误（这是 [第 6 章 “顺序程序中的错误处理”](../part-ii/Ch06-error_handling_in_sequential_programs.md) 的主题），但当这样做失败，或整个机器失效时，我们就要让某个别的进程修复错误了。


## 让其崩溃


当咱们来自于像是 C 这样的某门语言时，这就会听起来非常奇怪。在 C 中，我们被教导编写 *防御性代码*。程序应检查其参数，且不要崩溃。在 C 中，这样做有个很好的理由：编写多进程的代码极其困难，同时大多数应用都只有一个进程，因此当这个进程崩溃掉整个应用时，咱们就会有大麻烦。不幸的是，这会导致大量与非错误检查代码交织在一起的错误检查代码。

在 Erlang 中，我们的做法恰恰相反。我们将咱们应用构建为两个部分：一部分解决问题，另一部分则会纠正已发生的错误。


解决问题的部分，会以尽量少的防御代码编写；我们假定函数的全部参数都是正确的，并且程序执行时不会出错。


纠正错误的部分，通常是 *通用的*，因此同样的纠错代码，可用于许多不同的应用。例如，在数据库事务中，当某次事务中途某处发生错误时，我们只需中止该事务，并让系统将数据库恢复到其在该错误前的状态。在某个操作系统中，当某个进程崩溃时，我们会让操作系统关闭所有打开的文件或套接字，并将系统恢复到某种稳定状态。


这种做法能将问题彻底分开。我们编写解决问题的代码，与修复故障的代码，但二者没有交织在一起。这可以大大减少代码量。



### 为何要崩溃掉？


出错时立即崩溃，往往是个极佳的主意；事实上，立即崩溃有诸多优点。



## 创建链接
