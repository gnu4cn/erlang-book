# 接口技术

系统的构建，经常涉及将以不同编程语言编写的应用，与咱们的系统连接起来。我们可能将 C 用于提高效率，或编写底层的硬件驱动，抑或我们可能打算集成某个以 Java、Ruby 或其他编程语言编写的库。我们可以数种方式，将一些外语程序与 Erlang 连接起来。


- 通过在某个外部操作系统进程中，在 Erlang 虚拟机 *外部* 运行程序。这是一种 *安全的* 方法。当外部语言的代码不正确时，也不会导致 Erlang 系统崩溃。Erlang 通过称为一种称作 *端口* 的设备，控制外部进程，并经由面向字节的通信信道，与外部进程通信。Erlang 负责启动及停止外部程序，并可监控他们，当其崩溃时重启他们。这些外部进程，被称为 *端口进程*，因为其是通过某个 Erlang 端口控制的；

- 在 Erlang 中运行某个操作系统命令，并捕获结果；

- 在 Erlang 虚拟机 *内部* 运行其他语言的代码。这涉及将外部代码，与 Erlang 虚拟机的代码链接起来。这是一种 *不安全的* 方法。其他语言代码中的错误，可能会导致 Erlang 系统崩溃。虽然这种方法不安全，但却很有用，因为相比使用外部进程，他更有效率。

    将其他语言代码链接进到 Erlang 内核，只能用于 C 等生成原生对象代码的那些语言，而不能用于 Java 等有其自己虚拟机的那些语言。

在本章中，我们将学习使用端口和操作系统命令，连接 Erlang。此外，还有一些使用链接驱动、原生实现函数（NIFs）及 C 节点等高级接口技术。这些高级技术未在本书中涉及，但在本章末尾，我们将简要介绍这些技术，并提供一些参考资料。

> *知识点*：
>
> - linked-in drivers
>
> - natively implemented functions, NIFs
>
> - C-nodes


## Erlang 如何与外部程序通信


Erlang 通过名为 *端口* 的对象，与外部程序通信。当我们将一条消息发送给某个端口时，该消息将被发送到与该端口相连的外部程序。而来自外部程序的消息，将呈现为来自端口的 Erlang 消息。


就程序员而言，端口的行事方式，与 Erlang 进程无异。咱们可将消息发送给他，咱们可将其注册（就像进程一样），等等。当外部程序崩溃时，那么一个退出信号，将发送到所连接的进程，而当连接的进程死亡时，则对应外部程序也会被杀死。


请注意使用端口与外部进程通信，与使用套接字与外部程序通信的区别。当咱们使用端口时，端口将以 Erlang 进程方式行事，因此咱们可以链接到他，从远端的分布式 Erlang 节点发送消息给他等等。而当咱们使用套接字时，其将不会以进程方式行事。


创建了端口的进程，称为该端口的 *连接进程*。连接进程具有显著意义：所有发送到该端口的消息，都必须以连接进程的 PID 标记，同时所有来自外部程序的消息，都会发送到这个连接进程。


我们可以在下图中，看到连接进程（C）、端口（P）与外部操作系统进程间的关系：

![Erlang 端口](../images/erlang_ports.png)


要创建一个端口，我们就要调用 `open_port`，其是如下指定的：


```erlang
-spec open_port(PortName, [Opt]) -> Port
```

其中 `PortName` 为如下选项之一：

- `{spawn, Command}`

    会启动一个外部程序。`Command` 是某个外部程序的名字。除非找到一个名称为 `Command` 的链接驱动，否则 `Command` 会运行于 Erlang 工作区之外。


- `{fd, In, Out}`

    允许 Erlang 进程访问当前由 Erlang 打开的任何文件描述符。其中文件描述符 `In` 可用于标准输入，而文件描述符 `Out` 则可用于标准输出。


`Opt` 为以下选项之一：

- `{packet, N}`

    数据包前面有 `N`（1、2 或 4）字节的长度计数。

- `stream`

    发送以不带数据包长度发出。应用务必要知道，如何处理这些数据包。

- `{line, Max}`

    按行投送信息。当行超过 `Max` 字节数时，则其会被分拆为 `Max` 字节。

- `{cd, Dir}`

    只对 `{spawn, Command}` 这个选项有效。外部程序会在 `Dir` 下启动。


- `{env, Env}`

    只对 `{spawn, Command}` 这个选项有效。外部程序的环境，由列表 `Env` 中的环境变量扩展。`Env` 是个 `{VarName, Value}` 对的列表，其中 `VarName` 和 `Value` 均为字符串。


这并非 `open_port` 的参数完整列表。咱们可以在 `erlang` 模组的手册页中，找到这些参数的详细信息。

以下消息可被发送给某个端口；请注意，在所有这些消息中，`PidC` 都是所连接进程的 PID。


- `Port ! {PidC, {command, Data}}`

    向该端口发送 `Data` （一个 I/O 清单）。


- `Port ! {PidC, {connect, Pid1}}`

    将连接进程的 PID，从 `PidC` 改为 `Pid1`。

- `Port ! {PidC, close}`

    关闭该端口。


通过写下如下代码，连接进程就可以接收来自外部程序的消息：


```erlang
receive
    {Port, {data, Data}} ->
        ... Data comes from the external process ...
```


在后面的小节中，我们将把 Erlang 与一个简单 C 程序对接。这个 C 程序有意较短，以专注于我们如何完成对接的细节。


## 使用端口对接外部 C 程序


我们将以一些简单 C 代码开始。`example1.c` 包含着两个函数。第一个函数计算两个整数之和，第二个计算其参数的二倍。

[`ports/example1.c`](http://media.pragprog.com/titles/jaerlang2/code/ports/example1.c)

```c
{{#include ../../projects/ch15-code/example1.c}}
```

我们的最终目标，是在 Erlang 中调用这些例程。我们希望能以如下方式调用他们：


```erlang
X1 = example1:sum(12,23),
Y1 = example1:twice(10),
```


从用户角度看，`example1` 就是个 Erlang 模组，因此到这个 C 程序的接口的所有细节，都应隐藏在 `example1` 这个模组内部。


要实现这点，我们需要将诸如 `sum(12,23)` 与 `twice(10)` 等函数调用，转换为我们通过端口的方法，发送给外部程序的字节序列。端口将一个长度计数，添加到这个字节序列，并将得到的结果发送给外部程序。当外部程序回复时，端口会收到该回复，并将结果发送给该端口的连接进程。


我们使用的协议非常简单。


- 所有数据包都以 2 字节的长度编码 (`Len`) 开始，然后是 `Len` 个字节的数据。当我们以参数 `{packet,2}` 打开某个端口时，这个头部是由端口自动添加的；

- 我们将调用 `sum(N, M)`，编码为字节序列 `[1,N,M]`；

- 我们将调用 `twice(N)` 编码为字节序列 `[2,N]`；

- 参数和返回值，均被假定为单个字节长。


外部的 C 程序和 Erlang 程序，都必须遵循这一协议。下图说明了在我们调用 `example1:sum(12,23)` 后，所发生的事情。他显示了端口是如何连接到外部 C 程序的。


![端口协议](../images/port_protocol.png)

发生的事情如下：

1. 驱动会将 `sum(12,23)` 这个函数调用，编码为字节序列 `[1,12,23]`，并将 `{self(), {command, [1,12,23]}}` 这个消息，发送到端口；

2. 端口驱动会将一个 2 字节的长度头部，添加到该消息，而把字节序列 `0,3,1,12,13` 发送给外部程序；

3. 外部程序会从标准输入，读取这五个字节，调用那个求和函数，然后将字节序列 `0,1,35` 写入标准输出；

    其中前两个字节包含着数据包的长度。随后便是结果 `35`，其为 1 字节长。

4. 端口驱动会移除那个长度的头部，并将一条 `{Port, {data, [35]}}` 消息发送给连接进程；

5. 连接进程会解码出这条消息，并将结果返回给调用程序。

现在，我们必须编写出遵循这一协议，位于接口两侧的程序。


### C 程序


C 程序有三个文件。

- `example1.c`：包含着我们要调用的函数（早先我们已见到这个文件）；
- `example1_driver.c`：管理字节流协议，以及调用 `example1.c` 中的例程；
- `erl_comm.c`：具有一些读写内存缓冲区的例程；


**`example1_driver.c`**


这段代码有个读取标准输入中命令、调用应用例程，并将结果写入标准输出的循环。请注意，当咱们打算调试这个程序时，咱们可写入 `stderr`；代码中有条注释掉的 `fprintf` 语句，展示了怎样做到这点。


[`ports/example1_driver.c`](http://media.pragprog.com/titles/jaerlang2/code/ports/example1_driver.c)


```c
{{#include ../../projects/ch15-code/example1_driver.c}}
```


**`erl_comm.c`**


最后，下面是读写和写入标准输入和输出中数据的代码。这段代码被编写为允许可能的数据碎片。

[`ports/erl_comm.c`](http://media.pragprog.com/titles/jaerlang2/code/ports/erl_comm.c)


```c
{{#include ../../projects/ch15-code/erl_comm.c}}
```

这段代码专门用于处理有着 2 字节长头部的数据，因此他要与给到端口驱动程序的 `{packet, 2}` 选项匹配。


### Erlang 程序



