# 二进制值与位语法

所谓 *二进制值* 是一种设计用于以节省空间的方式，存储大量原始数据的数据结构。Erlang 虚拟机在二进制值的高效输入、输出和消息传递等方面，进行了优化。

在存储大量非结构化数据内容，例如大型字符串或文件的内容时，应尽可能使用二进制值。


在大多数情况下，某个二进制值的比特（二进制位）数，将正好能被 8 整除，而因此会对应到一个字节序列。当比特数不能被 8 整除时，我们就会用 *比特串* 来指代该数据。当咱们讲 “比特串” 时，就是要强调该数据的位数，不是 8 的整数倍。


二进制值、比特串及位级的模式匹配被引入 Erlang，是为简化网络编程，其中我们经常需要探究协议数据包的位与字节级别的结构。


在本章中，我们将首先详细介绍二进制值。二进制值上的大多数操作，都会以同样方式作用于比特串，因此在了解二进制值后，我们将重点介绍比特串与二进制值的不同之处。


*知识点*：


- binary
- bitstring
- bit-level pattern match


## 二进制值


二进制值是以由成对的小于和大于括符，括起来的整数或字符串序列形式写下及打印出来的。下面是个示例：


```erlang
1> <<5,10,20>>.
<<5,10,20>>
2> <<"hello">>.
<<"hello">>
3> <<65,66,67>>.
<<"ABC">>
```


当咱们在某个二进制值中用到整数时，则每个整数必须在范围 `0` 到 `255` 中。二进制值 `<<"cat">>` 是 `<<99,97,116>>` 的简称；也就是说，二进制是由该字符串中那些字符的 ASCII 字符编码组成的。


与字符串一样，当某个二进制值的内容，是个可打印字符串时，那么 shell 将把该二进制值，打印为一个字符串；否则，他将被打印为一个整数序列。


使用 BIF 或位语法（参见 [7.2 小节，位语法](#位语法)），我们可构建出一个二进制值，以及提取某个二进制值中的元素。在这一小节中，我们将只讨论操作二进制值的那些 BIFs。


### 使用二进制值

我们可使用 BIFs， 或 `binary` 模组中的那些函数操作二进制值。`binary` 中导出的许多函数,都是作为原生代码实现的。下面是一些最重要的函数：


- `list_to_binary(L) -> Bin`

`list_to_binary` 返回一个经由 *展开* （所谓 *展开*，是指移除全部列表括号）该 *iolist* `L` 中的所有元素，构建出的二进制值。而所谓 *iolist*，则被递归地元素是 `0..255` 中整数、一些二进制值或 `iolists` 的列表。


```erlang
1> Bin1 = <<1,2,3>>.
<<1,2,3>>
2> Bin2 = <<4,5>>.
<<4,5>>
3> Bin3 = <<6>>.
<<6>>
4> list_to_binary([Bin1, 1, [2,3,Bin2], 4|Bin3]).
<<1,2,3,1,2,3,4,5,4,6>>
```


*注意*：第 1 行中等号两边的空格是必要的。若没有这个空格，那么被 Erlang 的标记符号转换器看到的第二个符号，将是原子 `'=<'`，即等于或小于运算符。有时，我们必须在二进制字面值周围，加上空格或括号，避免语法错误。

- `split_binary(Bin, Pos) -> {Bin1, Bin2}`
- `term_to_binary(Term) -> Bin`
- `binary_to_term(Bin) -> Term`
- `byte_size(Bin) -> Size`
