# 一种简单执行环境

在这一附录中，我们将构建一种运行 Erlang 程序的简单执行环境，a simple execution environment, SEE。这些代码放在一个附录中，而不是本书正文中，是因为其在性质上有很大不同。本书中的所有代码，都是意图在标准 Erlang/OTP 发行版中运行，而这些代码则有意最小化使用 Erlang 的库代码，而尝试仅使用 Erlang 的那些元语。

当第一次接触 Erlang 时，往往会分不清对于哪些东西属于这门语言，哪些属于运行环境。OTP 提供了一个丰富环境，类似于为运行一些长寿命分布式 Erlang 应用的一个操作系统。而由 Erlang（语言）和 OTP（环境）究竟分别提供了哪些功能，则并不清楚。


SEE 提供了 “更接近裸机” 的环境，给到了 Erlang 所提供功能，与 OTP 所提供功能间更明显的区分。SEE 提供的所有功能，都包含在一个模组中。OTP 会以加载 60 多个模组启动，这些东西的工作原理虽然并不立即可见，但当咱们知道从哪里入手时，这些都不是特别复杂。起点是那个引导文件。从查看引导文件开始，然后阅读 `init.erl` 中的代码，一切就会水落石出。


SEE 环境可用于编写脚本，因为他启动非常快，或者用于嵌入式编程，因为他非常小。要达成此目标，咱们将了解 Erlang 如何启动，以及代码自动加载系统工作原理。


当咱们启动一个 “标准” Erlang 系统时（使用 shell 命令 `erl`），67 个模组会被加载，25 个进程会被启动，然后咱们的程序才得以运行。这一过程耗时大约一秒钟。当我们打算执行的程序，不需要由标准系统提供的全部这些时，我们便可将这个时间，缩短到数十毫秒。


弄清这 67 个模组与流程的到底做了些什么，可能让人望而生畏。不过，有一条不同的捷径，可让咱们豁然开朗。SEE 将系统简化为只需研究一个模组，就能了解代码如何被加载到系统中，以及 I/O 服务怎样被提供。SEE 在一个模组中，提供了自动加载、通用服务器进程及错误处理。


在开始介绍 SEE 前，我们将收集一些我们稍后用于引用的，有关 OTP 系统的统计数据。

```erlang
$ erl
1> length([I || {I,X} <- code:all_loaded(), X =/= preloaded]).
93
2> length(processes()).
45
3> length(registered()).
28
```

> **译注**：以下是在加上一些常用命令行参数后的结果。
>
> ```erlang
> $
> $ erl -boot start_sasl -config elog4 -smp +S 12 -pa _build/default/lib/math_server/ebin
> 1> length([I || {I, X} <- code:all_loaded(), X =/= preloaded]).
> 98
> 2> length(processes()).
> 52
> 3> length(registered()).
> 33
> ```


`code:all_loaded()` 会返回当前加载到系统中所有模组的列表，`processions()` 是个会返回系统已知的所有进程列表，而 `registered()` 则会返回所有注册进程的列表。

因此，仅启动系统就会加载 67 个模组，启动 25 个进程，其中 16 个是注册进程。我们来看看咱们能否降低这个数字。



