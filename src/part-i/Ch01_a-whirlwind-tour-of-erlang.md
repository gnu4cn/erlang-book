# Erlang 旋风之旅


在本章中，我们将构建我们的首个并发程序。我们将构造一个文件服务器。该文件服务器有两个并发进程：一个进程代表服务器，另一个代表客户端。


我们将从一个小的 Erlang 子集开始，这样我们就可以展示一些广泛的原则，而不必纠缠于细节。至少，我们必须了解如何在 shell 中运行代码及编译模组。这就是我们入门所需的全部知识。


学习 Erlang 的最佳方法，是将示例输入到实际的 Erlang 系统中，看看能否重现书中的内容。要安装 Erlang，请参阅 [Installation Guide](https://www.erlang.org/docs/22/installation_guide/users_guide)。我们会尽量更新安装说明。这很困难，因为有许多不同平台以不同方式进行配置。如果这些安装指令失败或不是最新的，请发送邮件到 Erlang 的邮件列表，我们会尽力提供帮助。


## 关于 Erlang shell


Erlang shell 是咱们将耗费咱们大部分时间的地方。在咱们输入某个表达式后，shell 就会对该表达式求值并打印结果。


```shell
$ werl
Erlang/OTP 28 [erts-16.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

Eshell V16.0.2 (press Ctrl+G to abort, type help(). for help)
1> 123456 * 223344.
27573156864
2>
```

那么，发生了什么？其中 `$` 是操作系统的提示符。我们输入了 `werl` 命令，他启动了 Erlang shell。Erlang shell 会以一个横幅及编号的提示 `1>` 响应。然后，我们输入了一个表达式，该表达式被求值并打印出来。注意每个表达式都 *必须* 以一个句点结束，后跟一个空格符。在这个语境下，空格是指空格、制表符或回车符。


初学者经常会忘记用这个点空白位，结束表达式。请把命令想象成英语句子。英语的句子通常以句点结束，因此很容易记住。


### `=` 运算符


使用 `=` 运算符，我们可以为变量赋值（严格来说，这叫做将该变量 *绑定* 到某个值），就像这样：


```erlang
2> X = 123.
123
3> X * 2.
246
```

若我们试图更改某个变量的值，就会发生一些奇怪的事情。

```erlang
4> X = 999.
** exception error: no match of right hand side value 999
```

这是第一个惊喜。我们无法 *重新绑定* 变量。Erlang 是门函数式语言，所以一旦我们说 `X = 123`，那么 `X` 就永远是 `123`，不能更改！


别担心，这是个好处，不是个问题。想比于同一变量在程序生命周期可获得许多不同值的程序，其中变量一旦设定就不能更改的程序要更容易理解。


当我们看到类似 `X = 123` 这样的表达式时，他的意思似乎是 “将整数 `123` 赋值给变量 `X`”，但这种解释是不正确的。`=` 不是个赋值运算符；他实际上是个 *模式匹配运算符*。这在 [变量绑定和模式匹配](../part-ii/Ch03-basic_concepts.md#变量绑定与模式匹配) 小节会详细介绍。


与在函数式编程语言中一样，Erlang 中的变量只能绑定一次。绑定某个变量意味着给了变量一个值；一旦其被绑定，以后该值就不能被更改。


如果咱们习惯了命令式语言，可能会觉得这种想法很奇怪。在命令式语言中，变量实际上是一种指向内存地址的变相方式。某个程序中的 `X`，其实就是内存中某个数据项的地址。当我们说 `X=12` 时，我们是在改变地址为 `X` 处内存位置的值，但在 Erlang 中，变量 `X` 表示了一个永远不会被改变的值。



### 变量与原子的语法

**Syntax of Variables and Atoms**



