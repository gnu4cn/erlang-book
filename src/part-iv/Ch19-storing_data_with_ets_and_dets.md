# 使用 ETS 和 DETS 存储数据

`ets` 和 `dets` 是两个咱们可用作大量 Erlang 项高效存储的系统模组。ETS 是 *Erlang term storage* 的简写，而 DETS 是 *disk ETS* 的简写。

ETS 和 DETS 执行基本同样的任务：他们提供了大型的键值查找表。ETS 属于内存驻留，而 DETS 则属于磁盘驻留。ETS 是相当高效率的 -- 使用 ETS 时，咱们可存储大量数据（只要咱们有足够内存），并可在恒定（或在某些情况下对数）时间内执行查找。DETS 提供与 ETS 几乎同样的一些接口，但将数据表存储在磁盘上。由于 DETS 使用磁盘存储，因此他要比 ETS 慢得多，但运行时将有着小得多的内存足迹。此外，ETS 和 DETS 的数据表，可由多个进程共用，使公共数据的进程间访问效率非常高。


ETS 和 DETS 的数据表，均是 *键* 与 *值* 关联的一些数据结构。对数据表的最常执行操作，是 *插入* 和 *查找*。ETS 或 DETS 数据表，只是 Erlang 元组的集合。


存储在 ETS 数据表中的数据，被存储在 RAM 中，是 *短暂的*。当 ETS 数据表被弃置，或所属 Erlang 进程终止时，这些数据就将被删除。存储在 DETS 数据表中的数据，则是 *持久性的*，并在整个系统崩溃后，应仍存活。当某个 DETS 数据表被打开时，其会受一致性检查。当其被发现损坏时，那么就会进行修复该数据表的尝试（由于该数据表中的所有数据都会检查，此操作可能需要很长时间）。


此操作应会恢复该数据表中的所有数据，不过，当该数据表中最后一个条目在系统崩溃时正被构造，则其可能会丢失。


ETS 数据表被广泛应用于那些必须高效处理大量数据的应用，其中使用非破坏性赋值，及 “纯” Erlang 数据结构编程的成本太高。

ETS 的数据表看起来像是以 Erlang 实现，但实际上他们是在底层运行时系统中实现的，与普通 Erlang 对象相比有着不同性能特征。特别是，ETS 的数据表不会被垃圾回收；这意味着在使用超大 ETS 数据表时，没有垃圾回收代价，但在创建或访问 ETS 对象时，会产生轻微代价。


## 数据表的类型

ETS 和 DETS 表存储的是元组。元组中的一个元素（默认下第一个元素）称为数据表的 *键*。我们会根据键，向数据表中插入元组及从数据表中提取元组。当我们向数据表中插入元组时，会发生什么，取决于该数据表的类型及键的值。有的称为 *集合* 的数据表，要求数据表中所有键都是唯一的。而另一些称为 *包* 的数据表，则允许多个元组有着同样的键。


选择正确类型的数据表，对咱们应用性能，有重要影响。


基本的集合和包数据表类型，又各有两个变种，构成了总共四种类型的数据表：

- 集合，sets
- 有序集合，ordered sets
- 包，bags
- 重复包，duplicate bags


在集合下，数据表中不同元组的所有键，都必须唯一。而在有序集合中，元组是排序的。在包下，可以有多个有着同一键的元组，但包中不能有两个相同的元组。而在重复包中，多个元组可以有着同一键，同时同一元组可在同一个数据表中出现多次。


对 ETS 和 DETS 数据表，有四种基本操作。

- *创建新数据表或打开现有数据表*；

    我们以 `ets:new` 或 `dets:open_file` 完成此操作。


- *将一个或多个元组插入数据表*；

    这里我们调用 `insert(TableId,X)`，其中 `X` 是个元组或元组列表。在 ETS 和 DETS 下，`insert` 有着同样参数，且工作方式相同。

- *在数据表中查找某个元组*；

    这里我们调用 `lookup(TableID, Key)`。结果是个与 `Key` 匹配的元组列表。`lookup` 是同时为 ETS 和 DETS 定义的。

    查找的返回值，始终是个元组列表。这样我们就可以对数据包和数据集，使用同一个查找函数。当数据表类型是包时，那么多个元组就可以有同一个键，而当数据表类型是集合时，那么在查找成功时，该列表中就将只有一个元素。我们将在下一小节中，讨论数据表类型。

    当表中没有元组有着所需键时，则空列表即被返回。


- *弃置数据表*；

    当我们使用完毕某个数据表后，我们可通过调用 `dets:close(TableId)` 或 `ets:delete(TableId)` 告诉系统。


我们可以下面的这个小测试程序，演示他们的工作原理：


```erlang
{{#include ../../projects/ch19-code/ets_test.erl}}
```


这个程序会以四种模式之一创建一个 ETS 数据表，并将元组 `{a,1}`、`{b,2}`、`{a,1}` 和 `{a,3}` 插入该表。然后我们调用将整个数据表转换为列表的 `tab2list`，并将其打印。


当我们运行这个程序时，我们会得到以下输出：

```erlang
1> ets_test:start().
set           => [{b,2},{a,3}]
ordered_set   => [{a,3},{b,2}]
bag           => [{b,2},{a,1},{a,3}]
duplicate_bag => [{b,2},{a,1},{a,1},{a,3}]
ok
```

对于集合的数据表类型，每个键都只会出现一次。当我们将元组 `{a,1}` 插入该表，然后再插入 `{a,3}` 时，那么最终值将是 `{a,3}`。集合与有序集合的唯一区别是，有序集合中的元素是按键排序的。当我们通过调用 `tab2list` 将该表转换为列表时，我们就可以看到这种顺序。

包数据表类型，可以有键的多次出现。因此，举例来说，当我们插入 `{a,1}` 之后又插入 `{a,3}`，那么这个包将同时包含这两个元组，而不仅是最后那个。在重复包中，允许多个相同元组在包中，因此当我们将 `{a,1}` 插入到该包中后在插入 `{a,1}` 时，得到的数据表中就包含了`{a,1}` 元组的两份拷贝；而在普通包中，则只有该元组的一个副本。


## ETS 数据表效率的考量


在内部，ETS 表是以哈希表表示的（有序集合除外，其是以平衡二叉树表示）。这意味着使用集合，会有轻微的空间代价，而使用有序集合则会有时间代价。插入集合的操作会以恒定时间完成，但插入有序集合会以表中条目数的对数，成正比的时间完成。


当咱们要在集合和有序集合间选择时，咱们应考虑数据表在构建出后，咱们打算用他们做什么 -- 若咱们想要个排序表，那么就用有序集合。

由于每次插入时有着同一键的元素都要比较是否相等，因此相比使用重复包，使用包的开销要更高。当有大量有着同样键的元组时，这样做可能会相当低效。


ETS 的数据表，被存储在与正常进程内存没有关联的独立存储区中。ETS 数据表被说成是由创建他的进程所有 -- 当该进程死亡，或 `ets:delete` 被调用时，该表就会被删除。ETS 的数据表不会被垃圾回收，这意味着数据表中可存储大量数据，而不会产生垃圾回收代价。

当某个元组被插入到一个 ETS 数据表中时，代表该元组的所有数据结构，都会从进程栈和堆上，拷贝到这个 ETS 数据表中。当在数据表上执行一次查找操作时，结果元组会从这个 ETS 数据表，拷贝到进程的栈和堆上。

除大型二进制值外，对于所有数据结构都是如此。大型二进制值会被存储在他们自己的堆外存储区域。此区域可被多个进程及 ETS 数据表共用，同时单独的二进制值，会在一个引用计数的垃圾回收器下受管理，这种垃圾回收器会跟踪有多少个不同进程，和多少个 ETS 数据表使用着该二进制值。当使用某个特定二进制值的进程和数据表使用计数降为零时，那么该二进制值的存储区域即可被回收。


所有这一切听起来可能相当复杂，但其结果是，在进程间发送包含大型二进制值的消息非常便宜，将元组插入包含二进制值的 ETS 数据表也非常便宜。将二进制值尽可能多地用于表示字符串及未类型化的大型内存块，便是一条良好规则。


## 创建 ETS 数据表


通过调用 `ets:new`，我们即可创建 ETS 的数据表。创建数据的进程，称为该数据表的 *所有者*。当咱们创建数据表时，其有组不可更改的选项。当所有者进程死亡时，数据表的空间会被自动重新分配。咱们可通过调用 `ets:delete`，删除数据表。


`ets:new` 的参数如下：

+ `-spec ets:new(Name, [Opt]) -> TableId`

    其中 `Name` 是个原子。`[Opt]` 是个选项列表，取自以下选项：

    - `set | ordered_set | bag | duplicate_bag`

        这将创建一个给定类型（我们前面已经讨论过这些类型）的 ETS 数据表。

    - `private`

        这会创建出一个私有表。只有所有者进程，才能读写该数据表。

    - `public`

        这会创建一个公共表。任何知道表标识符的进程，都可以读写该表。

    - `protected`

        这会创建一个受保护的数据表。任何知道表标识符的进程都可以读该表，但只有所有者进程才可以写入该表。

    - `named_table`

        当该选项出现时，那么 `Name` 就可用于随后的数据表操作。

    - `{keypos, K}`

        使用 `K` 作为键的位置。通常情况下，位置 `1` 会被用作键。可能只有当我们存储其中第一个元素，包含着记录名字的 Erlang 记录（这实际上是个伪装的元组）时，我们才会使用这个选项。


*注意*：在零个选项下，打开某个 ETS 数据表，与在 `[set,protected,{keypos,1}]` 选项下打开他，是同样的。


本章中的所有代码，都使用 `protected` 的 ETS 数据表。受保护的数据表特别有用，因为他们允许以几乎零成本方式共享数据。所有知道表标识符的本地进程，都可以读取数据，但只有一个进程可以更改表中的数据。


> **将 ETS 数据表比作黑板**
>
> 受保护数据表，提供了某种类型 “黑板系统”。咱们可把一个受保护的 ETS 数据表，看作是一种命名黑板。任何知道这个黑板名字的人，都可以读这块黑板，但只有所有者才能在黑板上写。
>
> *注意*：以 `public` 模式打开的某个 ETS 数据表，可由任何知道该数据表名字的进程写和读。在这种情况下，用户必须确保到该数据表的读和些，以一致方式完成。


## ETS 的示例程序



