# 顺序 Erlang 的其余部分


对于顺序 Erlang，其余的就是一些咱们必须知道，但又不适合其他主题的零碎知识。这些主题没有特定逻辑顺序，所以他们只按字母顺序呈现，以便参考。涵盖的主题如下：


- [*内建函数 `apply`*](#apply)
- [*算术表达式*](#算术表达式)
- [*元数*](#元数)
- [*属性*](#属性)
- [*块表达式*](#块表达式)
- [*布尔值*](#布尔值)
- [*布尔表达式*](#布尔表达式)
- [*字符集*](#字符集)
- [*注释*](#注释)
- [*动态加载代码*](#动态加载代码)
- [*Erlang 的预处理器*](#erlang-的预处理器)
- [*转义序列*](#转义序列)
- [*表达式与表达式序列*](#表达式与表达式序列)
- [*函数的引用*](#函数的引用)
- [*包含文件*](#包含文件)
- [*列表的加法与减法运算符*](#列表的加法与减法运算符)
- [*宏*](#宏)
- [*模式中的匹配运算符*](#模式中的匹配运算符)
- [*数字*](#数字)
- [*运算符优级*](#运算符优先级)
- [*线程字典*](#线程字典)
- [*引用*](#引用)
- [*短路的布尔表达式*](#短路的布尔表达式)
- [*项的比较*](#项的比较)
- [*元组的模组*](#元组的模组)
- [*下划线变量*](#下划线变量)


## 内建函数 `apply`


`apply(Mod, Func, [Arg1, Arg2, ..., ArgN])` 这个 BIF，会将将模组 `Mod` 中的函数 `Func`，应用于参数 `Arg1, Arg2, ... ArgN`。他等同于调用如下函数：


```erlang
Mod:Func(Arg1, Arg2, ..., ArgN)
```

`apply` 可让咱们调用某个模组中的一个函数，传递给他参数。令其与直接调用该函数不同的是，其中的模组名和/或函数名，可被动态地计算。


在假定所有 Erlang BIFs 都属于 `erlang` 模组下，那么他们也都可以 `apply` 调用。因此，要构建对某个 BIF 的动态调用，我们可写出如下代码：


```erlang
1> apply(erlang, atom_to_list, [hello]).
"hello"
```


*警告*：`apply` 的使用应尽可能避免。当某个函数的参数事先知道时，使用 `M:F(Arg1,Arg2,...ArgN)` 形式的调用，就要比使用 `apply` 好得多。当对函数的调用，是以 `apply` 构建的时，许多分析工具无法计算出发生了什么，进而一些确切的编译器优化就无法进行。因此，请尽量少使用 `apply`，而只在绝对需要时才使用。


要应用的 `Mod` 参数不必是个原子；他还可以是个元组。当我们调用以下这个语句时：

```erlang
{Mod, P1, P2, ..., Pn}:Func(A1, A2, ..., An)
```


那么实际调用的是以下函数：


```erlang
Mod:Func(A1, A2, ..., An, {Mod, P1, P2, ..., Pn})
```


[24.3 节 “有状态模组”](../part-v/Ch24-programming_idioms.md#有状态模组) 将详细讨论这种技术。



## 算术表达式


### 整数


## 表达式与表达式序列

## 列表操作 `++` 与 `--`

## 包含文件
