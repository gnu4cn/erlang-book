# 使用 ETS 和 DETS 存储数据

`ets` 和 `dets` 是两个咱们可用作大量 Erlang 项高效存储的系统模组。ETS 是 *Erlang term storage* 的简写，而 DETS 是 *disk ETS* 的简写。

ETS 和 DETS 执行基本同样的任务：他们提供了大型的键值查找表。ETS 属于内存驻留，而 DETS 则属于磁盘驻留。ETS 是相当高效率的 -- 使用 ETS 时，咱们可存储大量数据（只要咱们有足够内存），并可在恒定（或在某些情况下对数）时间内执行查找。DETS 提供与 ETS 几乎同样的一些接口，但将数据表存储在磁盘上。由于 DETS 使用磁盘存储，因此他要比 ETS 慢得多，但运行时将有着小得多的内存足迹。此外，ETS 和 DETS 的数据表，可由多个进程共用，使公共数据的进程间访问效率非常高。


ETS 和 DETS 的数据表，均是 *键* 与 *值* 关联的一些数据结构。对数据表的最常执行操作，是 *插入* 和 *查找*。ETS 或 DETS 数据表，只是 Erlang 元组的集合。


存储在 ETS 数据表中的数据，被存储在 RAM 中，是 *短暂的*。当 ETS 数据表被弃置，或所属 Erlang 进程终止时，这些数据就将被删除。存储在 DETS 数据表中的数据，则是 *持久性的*，并在整个系统崩溃后，应仍存活。当某个 DETS 数据表被打开时，其会受一致性检查。当其被发现损坏时，那么就会进行修复该数据表的尝试（由于该数据表中的所有数据都会检查，此操作可能需要很长时间）。


此操作应会恢复该数据表中的所有数据，不过，当该数据表中最后一个条目在系统崩溃时正被构造，则其可能会丢失。


ETS 数据表被广泛应用于那些必须高效处理大量数据的应用，其中使用非破坏性赋值，及 “纯” Erlang 数据结构编程的成本太高。

ETS 的数据表看起来像是以 Erlang 实现，但实际上他们是在底层运行时系统中实现的，与普通 Erlang 对象相比有着不同性能特征。特别是，ETS 的数据表不会被垃圾回收；这意味着在使用超大 ETS 数据表时，没有垃圾回收代价，但在创建或访问 ETS 对象时，会产生轻微代价。


## 数据表的类型

ETS 和 DETS 表存储的是元组。元组中的一个元素（默认下第一个元素）称为数据表的 *键*。我们会根据键，向数据表中插入元组及从数据表中提取元组。当我们向数据表中插入元组时，会发生什么，取决于该数据表的类型及键的值。有的称为 *集合* 的数据表，要求数据表中所有键都是唯一的。而另一些称为 *包* 的数据表，则允许多个元组有着同样的键。


选择正确类型的数据表，对咱们应用性能，有重要影响。


基本的集合和包数据表类型，又各有两个变种，构成了总共四种类型的数据表：

- 集合，sets
- 有序集合，ordered sets
- 包，bags
- 重复包，duplicate bags


在集合下，数据表中不同元组的所有键，都必须唯一。而在有序集合中，元组是排序的。在包下，可以有多个有着同一键的元组，但包中不能有两个相同的元组。而在重复包中，多个元组可以有着同一键，同时同一元组可在同一个数据表中出现多次。


对 ETS 和 DETS 数据表，有四种基本操作。

- *创建新数据表或打开现有数据表*；

    我们以 `ets:new` 或 `dets:open_file` 完成此操作。


- *将一个或多个元组插入数据表*；

    这里我们调用 `insert(TableId,X)`，其中 `X` 是个元组或元组列表。在 ETS 和 DETS 下，`insert` 有着同样参数，且工作方式相同。

- *在数据表中查找某个元组*；

    这里我们调用 `lookup(TableID, Key)`。结果是个与 `Key` 匹配的元组列表。`lookup` 是同时为 ETS 和 DETS 定义的。

    查找的返回值，始终是个元组列表。这样我们就可以对数据包和数据集，使用同一个查找函数。当数据表类型是包时，那么多个元组就可以有同一个键，而当数据表类型是集合时，那么在查找成功时，该列表中就将只有一个元素。我们将在下一小节中，讨论数据表类型。

    当表中没有元组有着所需键时，则空列表即被返回。


- *弃置数据表*；

    当我们使用完毕某个数据表后，我们可通过调用 `dets:close(TableId)` 或 `ets:delete(TableId)` 告诉系统。


我们可以下面的这个小测试程序，演示他们的工作原理：


```erlang
{{#include ../../projects/ch19-code/ets_test.erl}}
```


这个程序会以四种模式之一创建一个 ETS 数据表，并将元组 `{a,1}`、`{b,2}`、`{a,1}` 和 `{a,3}` 插入该表。然后我们调用将整个数据表转换为列表的 `tab2list`，并将其打印。


当我们运行这个程序时，我们会得到以下输出：

```erlang
1> ets_test:start().
set           => [{b,2},{a,3}]
ordered_set   => [{a,3},{b,2}]
bag           => [{b,2},{a,1},{a,3}]
duplicate_bag => [{b,2},{a,1},{a,1},{a,3}]
ok
```

对于集合的数据表类型，每个键都只会出现一次。当我们将元组 `{a,1}` 插入该表，然后再插入 `{a,3}` 时，那么最终值将是 `{a,3}`。集合与有序集合的唯一区别是，有序集合中的元素是按键排序的。当我们通过调用 `tab2list` 将该表转换为列表时，我们就可以看到这种顺序。

包数据表类型，可以有键的多次出现。因此，举例来说，当我们插入 `{a,1}` 之后又插入 `{a,3}`，那么这个包将同时包含这两个元组，而不仅是最后那个。在重复包中，允许多个相同元组在包中，因此当我们将 `{a,1}` 插入到该包中后在插入 `{a,1}` 时，得到的数据表中就包含了`{a,1}` 元组的两份拷贝；而在普通包中，则只有该元组的一个副本。


## ETS 数据表效率的考量


在内部，ETS 表是以哈希表表示的（有序集合除外，其是以平衡二叉树表示）。这意味着使用集合，会有轻微的空间代价，而使用有序集合则会有时间代价。插入集合的操作会以恒定时间完成，但插入有序集合会以表中条目数的对数，成正比的时间完成。


当咱们要在集合和有序集合间选择时，咱们应考虑数据表在构建出后，咱们打算用他们做什么 -- 若咱们想要个排序表，那么就用有序集合。

由于每次插入时有着同一键的元素都要比较是否相等，因此相比使用重复包，使用包的开销要更高。当有大量有着同样键的元组时，这样做可能会相当低效。


ETS 的数据表，被存储在与正常进程内存没有关联的独立存储区中。ETS 数据表被说成是由创建他的进程所有 -- 当该进程死亡，或 `ets:delete` 被调用时，该表就会被删除。ETS 的数据表不会被垃圾回收，这意味着数据表中可存储大量数据，而不会产生垃圾回收代价。

当某个元组被插入到一个 ETS 数据表中时，代表该元组的所有数据结构，都会从进程栈和堆上，拷贝到这个 ETS 数据表中。当在数据表上执行一次查找操作时，结果元组会从这个 ETS 数据表，拷贝到进程的栈和堆上。

除大型二进制值外，对于所有数据结构都是如此。大型二进制值会被存储在他们自己的堆外存储区域。此区域可被多个进程及 ETS 数据表共用，同时单独的二进制值，会在一个引用计数的垃圾回收器下受管理，这种垃圾回收器会跟踪有多少个不同进程，和多少个 ETS 数据表使用着该二进制值。当使用某个特定二进制值的进程和数据表使用计数降为零时，那么该二进制值的存储区域即可被回收。


所有这一切听起来可能相当复杂，但其结果是，在进程间发送包含大型二进制值的消息非常便宜，将元组插入包含二进制值的 ETS 数据表也非常便宜。将二进制值尽可能多地用于表示字符串及未类型化的大型内存块，便是一条良好规则。


## 创建 ETS 数据表



