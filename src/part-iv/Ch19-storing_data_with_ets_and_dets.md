# 使用 ETS 和 DETS 存储数据

`ets` 和 `dets` 是两个咱们可用作大量 Erlang 项高效存储的系统模组。ETS 是 *Erlang term storage* 的简写，而 DETS 是 *disk ETS* 的简写。

ETS 和 DETS 执行基本同样的任务：他们提供了大型的键值查找表。ETS 属于内存驻留，而 DETS 则属于磁盘驻留。ETS 是相当高效率的 -- 使用 ETS 时，咱们可存储大量数据（只要咱们有足够内存），并可在恒定（或在某些情况下对数）时间内执行查找。DETS 提供与 ETS 几乎同样的一些接口，但将数据表存储在磁盘上。由于 DETS 使用磁盘存储，因此他要比 ETS 慢得多，但运行时将有着小得多的内存足迹。此外，ETS 和 DETS 的数据表，可由多个进程共用，使公共数据的进程间访问效率非常高。


ETS 和 DETS 的数据表，均是 *键* 与 *值* 关联的一些数据结构。对数据表的最常执行操作，是 *插入* 和 *查找*。ETS 或 DETS 数据表，只是 Erlang 元组的集合。


存储在 ETS 数据表中的数据，被存储在 RAM 中，是 *短暂的*。当 ETS 数据表被弃置，或所属 Erlang 进程终止时，这些数据就将被删除。存储在 DETS 数据表中的数据，则是 *持久性的*，并在整个系统崩溃后，应仍存活。当某个 DETS 数据表被打开时，其会受一致性检查。当其被发现损坏时，那么就会进行修复该数据表的尝试（由于该数据表中的所有数据都会检查，此操作可能需要很长时间）。


此操作应会恢复该数据表中的所有数据，不过，当该数据表中最后一个条目在系统崩溃时正被构造，则其可能会丢失。


ETS 数据表被广泛应用于那些必须高效处理大量数据的应用，其中使用非破坏性赋值，及 “纯” Erlang 数据结构编程的成本太高。

ETS 的数据表看起来像是以 Erlang 实现，但实际上他们是在底层运行时系统中实现的，与普通 Erlang 对象相比有着不同性能特征。特别是，ETS 的数据表不会被垃圾回收；这意味着在使用超大 ETS 数据表时，没有垃圾回收代价，但在创建或访问 ETS 对象时，会产生轻微代价。


## 数据表的类型

ETS 和 DETS 表存储的是元组。元组中的一个元素（默认下第一个元素）称为数据表的 *键*。我们会根据键，向数据表中插入元组及从数据表中提取元组。当我们向数据表中插入元组时，会发生什么，取决于该数据表的类型及键的值。有的称为 *集合* 的数据表，要求数据表中所有键都是唯一的。而另一些称为 *包* 的数据表，则允许多个元组有着同样的键。


选择正确类型的数据表，对咱们应用性能，有重要影响。


基本的集合和包数据表类型，又各有两个变种，构成了总共四种类型的数据表：

- 集合，sets
- 有序集合，ordered sets
- 包，bags
- 重复包，duplicate bags


在集合下，数据表中不同元组的所有键，都必须唯一。而在有序集合中，元组是排序的。在包下，可以有多个有着同一键的元组，但包中不能有两个相同的元组。而在重复包中，多个元组可以有着同一键，同时同一元组可在同一个数据表中出现多次。


对 ETS 和 DETS 数据表，有四种基本操作。

- *创建新数据表或打开现有数据表*；

    我们以 `ets:new` 或 `dets:open_file` 完成此操作。


- *将一个或多个元组插入数据表*；

    这里我们调用 `insert(TableId,X)`，其中 `X` 是个元组或元组列表。在 ETS 和 DETS 下，`insert` 有着同样参数，且工作方式相同。

- *在数据表中查找某个元组*；

    这里我们调用 `lookup(TableID, Key)`。结果是个与 `Key` 匹配的元组列表。`lookup` 是同时为 ETS 和 DETS 定义的。

    查找的返回值，始终是个元组列表。这样我们就可以对数据包和数据集，使用同一个查找函数。当数据表类型是包时，那么多个元组就可以有同一个键，而当数据表类型是集合时，那么在查找成功时，该列表中就将只有一个元素。我们将在下一小节中，讨论数据表类型。

    当表中没有元组有着所需键时，则空列表即被返回。


- *弃置数据表*；

    当我们使用完毕某个数据表后，我们可通过调用 `dets:close(TableId)` 或 `ets:delete(TableId)` 告诉系统。
