<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
  <head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>基本概念 - Erlang 编程</title>


    <!-- Custom HTML head -->

    <meta name="description" content="Programming Erlang, 2nd Edition, Joe Armstrong">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">
    <link rel="prefetch" href="../images/alipay-laxers.jpeg" />
    <link rel="prefetch" href="../images/wechat-pay-hector.jpeg" />

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../theme/pagetoc.css">

    <style type="text/css">
        a.button {
                color:white;
              font-family:Helvetica, sans-serif;
              font-weight:bold;
              font-size:12px;
              text-align: center;
              text-decoration:none;
              background-color:#FFA12B;
              display:inline-block;
              position:relative;
              padding:5px 10px;

              -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
              text-shadow: 0px 1px 0px #000;
              filter: dropshadow(color=#000, offx=0px, offy=1px);

              -webkit-box-shadow:inset 0 1px 0 #FFE5C4, 0 2px 0 #915100;
              -moz-box-shadow:inset 0 1px 0 #FFE5C4, 0 2px 0 #915100;
              box-shadow:inset 0 1px 0 #FFE5C4, 0 2px 0 #915100;

              -webkit-border-radius: 5px;
              -moz-border-radius: 5px;
              border-radius: 5px;
        }
    </style>

  </head>
  <body>
    <div id="body-container">
      <!-- Provide site root to javascript -->
      <script>
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
      </script>

      <!-- Work around some values being stored in localStorage wrapped in quotes -->
      <script>
        try {
                  var theme = localStorage.getItem('mdbook-theme');
                  var sidebar = localStorage.getItem('mdbook-sidebar');

                  if (theme.startsWith('"') && theme.endsWith('"')) {
                            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                          }

                  if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                          }
                } catch (e) { }
      </script>

      <!-- Set the theme before any content is loaded, prevents flash -->
      <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
      </script>

      <!-- Hide / unhide sidebar before it is displayed -->
      <script>
        var html = document.querySelector('html');
        var sidebar = null;
        if (document.body.clientWidth >= 1080) {
                  try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                  sidebar = sidebar || 'visible';
                } else {
                          sidebar = 'hidden';
                        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
      </script>

      <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
          <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="part-i.html"><strong aria-hidden="true">1.</strong> 第 I 部分，为何是 Erlang？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.1.</strong> 入门</a></li><li class="chapter-item expanded "><a href="part-i/Ch01_introducing-concurrency.html"><strong aria-hidden="true">1.2.</strong> 并发介绍</a></li><li class="chapter-item expanded "><a href="part-i/Ch02_a-whirlwind-tour-of-erlang.html"><strong aria-hidden="true">1.3.</strong> Erlang 旋风之旅</a></li></ol></li><li class="chapter-item expanded "><a href="part-ii.html"><strong aria-hidden="true">2.</strong> 第 II 部分，序列编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-ii/Ch03-basic_concepts.html"><strong aria-hidden="true">2.1.</strong> 基本概念</a></li><li class="chapter-item expanded "><a href="part-ii/Ch04-modules_and_functions.html"><strong aria-hidden="true">2.2.</strong> 模组与函数</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
      </nav>

      <div id="page-wrapper" class="page-wrapper">

        <div class="page">
          <div id="menu-bar-hover-placeholder"></div>
          <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
              <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
              </button>
              <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                <i class="fa fa-paint-brush"></i>
              </button>
              <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
              </ul>
            </div>

            <h3 class="menu-title">Erlang 编程</h3>

            <div class="right-buttons">
              <a href="https://github.com/gnu4cn/erlang-book" title="Git repository" aria-label="Git repository">
                <i id="git-repository-button" class="fa fa-github"></i>
              </a>
                <button class="open-button">打 赏 💰</button>
            </div>
          </div>


          <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
          <script>
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                          link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        });
          </script>

          <div id="content" class="content">
            <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
              <h1 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h1>
<p>本章介绍 Erlang 编程的背景。所有 Erlang 程序，无论并行还是顺序，都用到模式匹配、单赋值变量，以及 Erlang 用来表示数据的那些基本类型。</p>
<p>在本章中，我们将使用 Erlang shell 对系统进行实验，看看他会如何行事。我们将从 shell 开始。</p>
<h2 id="启动与停止-erlang-shell"><a class="header" href="#启动与停止-erlang-shell">启动与停止 Erlang shell</a></h2>
<p>在 Unix 系统（包括 Mac OS）上，咱们在命令提示符处，启动 Erlang shell；在 Windows 系统上，则要点击 Windows 开始菜单中的 Erlang 图标（译注：在 CMD/PowerShell，或 Git Bash/MinGW/MSYS2 终端窗口中，也能获得 *nix 的体验）。</p>
<pre><code class="language-console">$ erl
Erlang/OTP 28 [erts-16.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

Eshell V16.0.2 (press Ctrl+G to abort, type help(). for help)
</code></pre>
<p>这是启动 Erlang shell 的 Unix 命令。shell 以一个告诉咱们正在运行哪个版本 Erlang 的横幅响应。停止系统的最简单方法，是按下 <code>Ctrl+C</code> （Windows 上 <code>Ctrl+Break</code>），然后按 <code>a</code>（abort 的缩写），如下所示：</p>
<pre><code class="language-console">BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo
       (l)oaded (v)ersion (k)ill (D)b-tables (d)istribution
a
$ 
</code></pre>
<p>输入 <code>a</code> 会立即停止系统，并可能导致一些数据损坏。要有控制地关闭系统，咱们可键入 <code>q()</code>（quit 的简写）。</p>
<pre><code class="language-erlang">$ erl
Erlang/OTP 28 [erts-16.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

Eshell V16.0.2 (press Ctrl+G to abort, type help(). for help)
1&gt; q().
ok
2&gt; %                                                                                                                                        $ werl
Erlang/OTP 28 [erts-16.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

Eshell V16.0.2 (press Ctrl+G to abort, type help(). for help)
1&gt; q().
ok
2&gt; %            
</code></pre>
<blockquote>
<p><strong>译注</strong>：这是在 Windows 系统上，使用 <code>erl</code> 与 <code>werl</code> 启动 Erlang shell 后，分别输入 <code>q().</code> 后的行为。</p>
</blockquote>
<p>这会以受控方式停止系统。所有打开的文件都会刷新并关闭，打开的数据库会被关闭（若在运行），且所有应用都会以有序方式关闭。<code>q()</code> 是 <code>init:stop()</code> 命令的 shell 别名。</p>
<p>要立即停止系统，请执行表达式 <code>erlang:halt()</code>。</p>
<p>若这些方法都不起作用，请阅读 <a href="Ch10-compiling_and_running_your_program.html#%E5%81%9C%E6%AD%A2-Erlang">停止 Erlang</a>。</p>
<h3 id="在-shell-中执行命令"><a class="header" href="#在-shell-中执行命令">在 shell 中执行命令</a></h3>
<p>当 shell 准备好接受某个表达式时，他会打印出命令提示符。</p>
<pre><code class="language-erlang">1&gt; X = 20.
20
</code></pre>
<p>咱们将看到，对话是从命令 1 处开始的（即 shell 打印了 <code>1&gt;</code>）。这意味着我们已启动了个新的 Erlang shell。在本书中，每当咱们看到一个以 <code>1&gt;</code> 开始的对话时，如果咱们想要 <em>完全</em> 重现书中的示例，就必须启动一个新的 shell。当某个示例以大于 1 的提示数字开始时，这意味着该 shell 会话，是延续之前的示例，因此咱们不必启动一个新 shell。</p>
<p>提示符处我们输入一个表达式。shell 就会计算该表达式并打印结果。</p>
<pre><code class="language-erlang">2&gt; X + 20. % and this is a comment
40
</code></pre>
<p>shell 打印出了另一个提示符，这次是表达式 2 的（因为每次输入一个新的表达式，命令编号都会增加）。</p>
<p>在第 2 行中，百分号 (<code>%</code>) 表示一条注释的开始。从百分号到行尾的所有文本，都被视为一条注释，会被 shell 和 Erlang 编译器忽略。</p>
<p>现在也许是对 shell 进行实验的好时机。请输入示例中那些与课文中完全相同的表达式，并检查咱们是否会得到与书中同样的结果。有些命令序列可以输入多次，但有些命令序列则只能输入一次，因为他们依赖于之前的命令。在出现任何错误时，最好的办法是中止该 shell，然后用一个新启动的 shell 再试一次。</p>
<h3 id="可能出错的事情"><a class="header" href="#可能出错的事情">可能出错的事情</a></h3>
<p>咱们不能把在本书中读到的所有内容，都输入 shell。<em>Erlang 模组中的语法形式，就并非表达式，进而 shell 无法理解</em>。尤其是，咱们无法在 shell 中输入注解；注解是以连字符开头的（如 <code>-module</code>、<code>-export</code> 等）。</p>
<p>可能出错的情况是，咱们开始键入了带引号的内容（即以单引号或双引号开头），但尚未键入与开头引号相同的结尾引号。</p>
<p>如果出现上述情况，最好键入一个额外的引号，然后用点空白完成该命令。</p>
<p><em>高级</em>：咱们可启动和停止多个外壳。详情请参阅 <a href="../part-ii/Ch10-compiling_and_running_your_program.html#shell-%E4%B8%8D%E5%86%8D%E5%93%8D%E5%BA%94">shell 不再响应</a>。</p>
<h3 id="erlang-shell-中命令的编辑"><a class="header" href="#erlang-shell-中命令的编辑">Erlang shell 中命令的编辑</a></h3>
<p>Erlang shell 包含了个内置的行编辑器。他能理解流行的 Emacs 编辑器中，所使用行编辑命令的子集。只需敲几下键盘，就能调回并编辑前几行。可用的命令如下所示（注意，<code>^Key</code> 表示咱们应按下 <code>Ctrl+Key</code>）：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><em>命令</em></th><th style="text-align: left"><em>描述</em></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>^A</code></td><td style="text-align: left">行开头处</td></tr>
<tr><td style="text-align: left"><code>^D</code></td><td style="text-align: left">删除当前字符</td></tr>
<tr><td style="text-align: left"><code>^E</code></td><td style="text-align: left">行结束处</td></tr>
<tr><td style="text-align: left"><code>^F</code> 或右箭头</td><td style="text-align: left">向前一个字符</td></tr>
<tr><td style="text-align: left"><code>^B</code> 或左箭头</td><td style="text-align: left">向后一个字符</td></tr>
<tr><td style="text-align: left"><code>^P</code> 或向上箭头</td><td style="text-align: left">前一行</td></tr>
<tr><td style="text-align: left"><code>^N</code> 或向下箭头</td><td style="text-align: left">下一行</td></tr>
<tr><td style="text-align: left"><code>^T</code></td><td style="text-align: left">专治最后两个字符</td></tr>
<tr><td style="text-align: left"><code>Tab</code></td><td style="text-align: left">尝试扩展当前模组或函数的名字</td></tr>
</tbody></table>
</div>
<p>随着经验的积累，咱们将发现 shell 是个非常强大的工具。最重要的是，当咱们开始编写分布式程序时，咱们将发现咱们可以把一个 shell， 连接到集群中不同 Erlang 节点上运行的 Erlang 系统，甚至可以直接通过安全 shell (<code>ssh</code>)，连接到运行在远端计算机上的 Erlang 系统。这样，咱们就可以与 Erlang 节点系统中，任何节点上的任何程序进行交互。</p>
<h2 id="简单的整数算术"><a class="header" href="#简单的整数算术">简单的整数算术</a></h2>
<p>咱们来计算一些算术表达式。</p>
<pre><code class="language-erlang">1&gt; 2 + 3 * 4.
14
2&gt; (2 + 3) * 4.
20
</code></pre>
<p>你会发现 Erlang 遵循算术表达式的常规规则，因此 <code>2 + 3 * 4</code> 表示 <code>2 + (3 * 4)</code> 而不是 <code>(2 + 3) * 4</code>。</p>
<p>Erlang 使用任意大小的整数，执行整数运算。在 Erlang 中，整数运算是精确的，因此咱们不必担心运算溢出，或无法用特定字大小表示整数。</p>
<p>为什么不试试呢？咱们可以非常大数计算，给朋友留下深刻印象。</p>
<pre><code class="language-erlang">3&gt; 123456789 * 987654321 * 112233445566778899 * 998877665544332211.
13669560260321809985966198898925761696613427909935341
</code></pre>
<p>咱们可以多种方法输入整数（详情请参阅 <a href="Ch08-the_rest_of_sequential_erlang.html#%E6%95%B4%E6%95%B0">整数</a>）。下面是一个使用基数 16 与基数 32 表示法的表达式：</p>
<pre><code class="language-erlang">4&gt; 16#cafe * 32#sugar.
1577682511434
</code></pre>
<p><em>知识点</em>：</p>
<ul>
<li>arbitrary-sized integers</li>
<li>a certain word size</li>
<li>Erlang 最高支持到 36 进制</li>
</ul>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>我们可将命令的结果，存储在某个变量中。</p>
<pre><code class="language-erlang">1&gt; X = 123456789.
123456789
</code></pre>
<p>在第一行中，我们给了变量 <code>X</code> 一个值；在下一行中，shell 就会打印出该变量的值。</p>
<p>请注意，所有变量名字，都 <em>必须</em> 以一个大写字母开头。</p>
<p>若咱们要查看某个变量的值，只需输入变量名即可。</p>
<pre><code class="language-erlang">2&gt; X.
123456789
</code></pre>
<p>现在 <code>X</code> 有了个值，咱们就可以使用他了。</p>
<pre><code class="language-erlang">3&gt; X*X*X*X.
232305722798259244150093798251441
</code></pre>
<p>但是，若咱们尝试将一个不同值赋给变量 <code>X</code>，咱们将得到一条错误消息。</p>
<pre><code class="language-erlang">4&gt; X = 1234.
** exception error: no match of right hand side value 1234
</code></pre>
<blockquote>
<p><strong>单一赋值就如同代数</strong></p>
<p>在我（作者）上学的时候，我的数学老师曾说：“如果在同一个等式中几个不同部分都有一个 <code>X</code>，那么所有的 <code>X</code> 都表示同一个意思”。这正是我们能解出方程的所在：如果我们知道 <code>X+Y=10</code> 和 <code>X-Y=2</code>，那么在这两个等式中，<code>X</code> 将是 6，<code>Y</code> 将是 4。</p>
<p>而当我（作者）学习第一门编程语言时，我们看到的就是这样的东西：</p>
<p><code>X = X + 1</code></p>
<p>大家都抗议，说：“你们不能这样做！” 但老师说我们错了，我们必须忘掉在数学课上学到的东西。</p>
<p>在 Erlang 中，变量就像他们在数学中一样。当咱们将某个值与某个变量关联时，咱们就是在做一个断言--一种事实的陈述。这个变量有了这个值。就是这样。</p>
</blockquote>
<p>为解释这里发生的事情，我必须打破咱们对这个简单语句 <code>X = 1234</code> 的两个假设。</p>
<ul>
<li>首先，<code>X</code> 不是个变量，不是咱们在 Java 与 C 语言中，所习惯的那种变量；</li>
<li>其次，<code>=</code> 不是个赋值运算符；而是模式匹配运算符。</li>
</ul>
<p>对 Erlang 新手来说，这可能是最棘手的问题之一，因此我们来深入探讨一下。</p>
<h3 id="erlang-变量不会变化"><a class="header" href="#erlang-变量不会变化">Erlang 变量不会变化</a></h3>
<p>Erlang 有的是 <em>单一赋值变量</em>。顾名思义，变量只能赋值一次。若咱们试图在某个变量被设置后，更改他的值，那么咱们将得到一个报错（事实上，咱们将会得到我们刚看到的 badmatch 错误）。已被赋值的变量，称为 <em>绑定</em> 变量，否则被称为 <em>未绑定</em> 变量。</p>
<p>在 Erlang 看到诸如 <code>X = 1234</code> 这样的语句，且 <code>X</code> 之前未被绑定时，他就会将变量 <code>X</code> 绑定到值 <code>1234</code> 上。在绑定前，<code>X</code> 可以取任何值：他只是个等待填充的空槽。但是，他一旦得到了某个值，就会永远保留。</p>
<p>说到这里，咱们可能会想知道，为什么我们要使用 <em>变量</em> 这个名字。这有两个原因。</p>
<ul>
<li>他们属于变量，不过其值只能更改一次（即他们会从未绑定，变为有个值）；</li>
<li>他们看起来像传统编程语言中的变量，所以当我们看到一行这样开头的代码时：</li>
</ul>
<pre><code class="language-erlang">X = ... %% '...' means 'Code I'm not showing'
</code></pre>
<p>然后我们的大脑就会说：“啊哈，我知道这是什么；<code>X</code> 是个变量，<code>=</code> 是个赋值运算符”。而我们的大脑几乎是正确的：<code>X</code> 几乎是个变量，而 <code>=</code> 几乎是个赋值运算符。</p>
<p>事实上，<code>=</code> 是个模式匹配运算符，当 <code>X</code> 是个未绑定变量时，他行为就类似于赋值。</p>
<p>最后，某个变量的 <em>作用域</em>，是他于其间被定义的某个词法单位，the <em>scope</em> of a variable is the lexical unit in which it is defined。因此，若 <code>X</code> 是在某个函数子句中用到，那么他的值就不会 “逃逸” 到这个子句外。同一个函数中不同子句之间，不存在共享的全局变量或私有变量。若 <code>X</code> 出现在许多不同的函数中，那么 <code>X</code> 的所有值都是不相关的。</p>
<h3 id="变量绑定与模式匹配"><a class="header" href="#变量绑定与模式匹配">变量绑定与模式匹配</a></h3>
<p>在 Erlang 中，变量获得值是一次模式匹配运算成功的结果。</p>
<p>在大多数语言中，<code>=</code> 表示一个赋值语句。但在 Erlang 中，<code>=</code> 则是一次 <em>模式匹配</em> 运算。<code>Lhs = Rhs</code> 的真正意思是：计算出右侧 (<code>Rhs</code>) ，然后将结果与左侧 (<code>Lhs</code>) 的模式匹配。</p>
<p>某个变量，如 <code>X</code>，是模式的一种简单形式。正如我们前面所说，变量只能被赋值一次。当我们 <em>第一次</em> 说 <code>X = SomeExpression</code> 时，Erlang 会对自己说：“我该怎么做才能让这条语句为真呢？” 因为 <code>X</code> 还没有一个值，所以他可以将 <code>X</code> 与 <code>SomeExpression</code> 的值绑定，该语句就变得有效了，大家都很高兴。</p>
<p>若稍后阶段我们又说 <code>X = AnotherExpression</code>，那么只有在 <code>SomeExpression</code> 和 <code>AnotherExpression</code> 相同时，匹配才会成功。下面是这方面的一些示例：</p>
<pre><code class="language-erlang">1&gt; X = (2+4).
6
</code></pre>
<p>在这条语句前，<code>X</code> 没有值，因此模式匹配会成功，<code>X</code> 被绑定到 <code>6</code>。</p>
<pre><code class="language-erlang">2&gt; Y = 10.
10
</code></pre>
<p>同样，<code>Y</code> 被绑定到 <code>10</code>。</p>
<pre><code class="language-erlang">3&gt; X = 6.
6
</code></pre>
<p>这与第 1 行有些许不同；在这个表达式被求值前，<code>X</code> 为 <code>6</code>，因此匹配会成功，同时 shell 会打印出该表达式的值，即 <code>6</code>。</p>
<pre><code class="language-erlang">4&gt; X = Y.
** exception error: no match of right hand side value 10
</code></pre>
<p>在这个表达式求值前，<code>X</code> 为 <code>6</code>，<code>Y</code> 为 <code>10</code>。<code>6</code> 不等于 <code>10</code>，因此会打印一条错误消息。</p>
<pre><code class="language-erlang">5&gt; Y = 10.
10
</code></pre>
<p>模式匹配成功，因为 <code>Y</code> 是 <code>10</code>。</p>
<pre><code class="language-erlang">6&gt; Y = 4.
** exception error: no match of right hand side value 4
</code></pre>
<p>这会失败，因为 <code>Y</code> 为 <code>10</code>。</p>
<p>在这个阶段，看起来我（作者）在故弄玄虚。<code>=</code> 左边的所有模式都只是变量，可以是绑定的，也可以是未绑定的，但正如我们稍后将看到的，我们可以构造任意复杂的模式，并用 <code>=</code> 操作符匹配他们。在我们引入了用于存储复合数据项的元组和列表后，我将回到这个主题。</p>
<blockquote>
<p><strong>没有副作用就意味着我们可以使我们的程序并行处理</strong></p>
<p>可修改内存区域的专业术语，叫做 <em>可变状态</em>。Erlang 是门函数式编程语言，有着不可变状态。</p>
<p>在本书后面部分，我们将研究如何编程多核的 CPU，并会发现有着不可变状态的好处是巨大的。</p>
<p>若咱们使用 C 或 Java 等传统编程语言编程多核 CPU ，咱们就必须面对 <em>共享内存</em> 的问题。为避免破坏共享内存，在访问内存时其就必须上锁。访问共享内存的程序，在操作共享内存时不得崩溃。</p>
<p>在 Erlang 中，就没有可变状态，没有共享内存，进而也没有锁。这使得我们的程序很容易并行化。</p>
</blockquote>
<h3 id="单一赋值为何会提升我们的程序"><a class="header" href="#单一赋值为何会提升我们的程序">单一赋值为何会提升我们的程序</a></h3>
<p>在 Erlang 中，一个变量只是对某个值的引用 -- 在 Erlang 的实现中，一个绑定的变量是由一个到包含着值的存储区域的指针表示的。这个值不可更改。</p>
<p>我们不能更改变量这一事实极为重要，且不同于 C 或 Java 等命令式语言中变量的行为。</p>
<p>使用不可变变量会简化调试。要理解为什么会这样，我们必须问问自己何谓错误，以及错误是如何暴露自己的。</p>
<p>我们发现某个程序不正确的一种相当常见方法是，我们发现某个变量有了未预期的值。一旦我们知道了哪个变量不正确，我们只需检查程序，找到该变量被绑定之处。由于 Erlang 变量是不可变的，因此产生该变量的代码一定是错误的。在命令式语言中，变量可以被多次更改，因此变量被更改的每个地方，都可能是错误发生的地方。而在 Erlang 中，只有一处要查找。</p>
<p>到这里，咱们可能会想，<em>没有</em> 可变变量可怎么编程？在 Erlang 中我们要怎么表达 <code>X = X + 1</code> 这样的事情呢？Erlang 的方式是引入一个其名字未曾用过的新变量（比如 <code>X1</code>），并写下 <code>X1 = X + 1</code>。</p>
<h2 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h2>
<p>我们来试着用浮点数做一些算术运算。</p>
<pre><code class="language-erlang">1&gt; 5/3.
1.6666666666666667
2&gt; 5/3.0.
1.6666666666666667
</code></pre>
<p>第 1 行中该行末尾的数字是整数 <code>3</code>。句点表示该表达式的结束，而不是个小数点。若我（作者）想在这里使用浮点数，就会写成 <code>3.0</code>。</p>
<p>当咱们以 <code>/</code> 除两个整数时，结果会自动转换为浮点数；因此，<code>5/3</code> 会求值为 <code>1.66666666666667</code>。</p>
<pre><code class="language-erlang">3&gt; 4/2.
2.0
</code></pre>
<p>尽管 <code>4</code> 恰好能被 <code>2</code> 整除，但结果依然是个浮点数而不是整数。要从除法中得到整数结果，我们必须使用运算符 <code>div</code> 和 <code>rem</code>。</p>
<pre><code class="language-erlang">4&gt; 5 div 3.
1
5&gt; 5 rem 3.
2
6&gt; 4 div 2.
2
</code></pre>
<p><code>N div M</code> 是 <code>N</code> 除以 <code>M</code> 并丢弃余数。而 <code>N rem M</code> 是 <code>N</code> 除以 <code>M</code> 后的余数。</p>
<p>Erlang 在内部使用 64 位的 IEEE 754-1985 浮点数，因此用到浮点数的程序，会遇到与浮点数相关的四舍五入或精度问题，咱们在 C 语言中也会遇到。</p>
<h2 id="原子"><a class="header" href="#原子">原子</a></h2>
<p>在 Erlang 中，原子用于表示常量值。</p>
<p>若咱们习惯了 C 或 Java 中的枚举类型，或者 Scheme 或 Ruby 中的符号，那么咱们就已经用到过与原子非常相似的东西。</p>
<p>C 程序员将对使用符号常量，使程序自文档化的惯例熟悉。典型的 C 程序会在包含大量常量定义的包含文件中，定义一组全局常量；例如，可能会有个包含以下内容的 <code>glob.h</code> 文件：</p>
<pre><code class="language-c">#define OP_READ 1
#define OP_WRITE 2
#define OP_SEEK 3
...
#define RET_SUCCESS 223
...
</code></pre>
<p>使用此类符号常量的典型 C 代码, 可能如下：</p>
<pre><code class="language-c">#include "glob.h"

int ret;
ret = file_operation(OP_READ, buff);
if( ret == RET_SUCCESS ) { ... }
</code></pre>
<p>在 C 程序中，这些常量的值并不重要；这里他们之所以重要，只是因为他们都不相同，并可比较他们是否相等。这个程序的 Erlang 对应程序，可能是这样的：</p>
<pre><code class="language-erlang">Ret = file_operation(op_read, Buff),

if
    Ret == ret_success -&gt;
      ...
</code></pre>
<p>在 Erlang 中，原子是全局的，且无需使用宏定义或包含文件，即可实现。</p>
<p>假设我们打算编写一个处理一周天数的程序。为此，我们就会使用原子 <code>monday</code>、<code>tuesday</code>......，表示星期。</p>
<p>原子以小写字母开头，后跟一串字母数字字符或下划线 (<code>_</code>) 或 at (<code>@</code>) 符号，例如，<code>red</code>、<code>december</code>、<code>cat</code>、<code>meters</code>、<code>yards</code>、<code>joe@somehost</code> 及 <code>a_long_name</code> 等。</p>
<p>原子也可以用单引号（<code>'</code>）括起来。在使用这种引号形式时，我们可创建以大写字母开头的原子（否则会被解释为变量），或包含非字母数字字符的原子，例如 <code>'Monday'</code>、<code>'Tuesday'</code>、<code>'+'</code>、<code>'*'</code>、<code>'an atom with spaces'</code>。咱们甚至可以为那些不需要加引号的原子加引号，因此 <code>'a'</code> 与 <code>a</code> 的含义完全相同。在一些语言中，单引号与双引号的互换使用。但 Erlang 中的情况并非如此。单引号的使用如前所述；双引号则用于限定字符串字面值。</p>
<p>原子的值就只是这个原子。因此，若我们给出的命令只是一个原子，那么 Erlang shell 将打印该原子的值。</p>
<pre><code class="language-erlang">1&gt; hello.
hello
</code></pre>
<p>谈论原子的值或整数的值似乎有点奇怪。但由于 Erlang 是门函数式编程语言，因此每个表达式都必须有个值。这包括了只是极其简单表达式的整数与原子。</p>
<h2 id="元组"><a class="header" href="#元组">元组</a></h2>
<p>设想我们要将固定数量的项目，归为单个实体。为此，我们要用到 <em>元组</em>。我们可通过把我们打算表示的值，括在大括号中，并用逗号分隔他们，创建出元组。例如，若我们想要表示某人的姓名和身高，我们可使用 <code>{joe, 1.82}</code>。这是个包含一个原子和一个浮点数的元组。</p>
<p>元组类似于 C 中的结构体，不同之处在于他们是匿名的。在 C 中，一个 <code>point</code> 类型的变量 <code>P</code> 可以声明如下：</p>
<pre><code class="language-c">struct point {
    int x;
    int y;
} P;
</code></pre>
<p>使用点运算符（<code>.</code>），我们就可以访问 C 结构体中的字段。因此，要设置点中的 <code>x</code> 和 <code>y</code> 值，我们可以这样说:</p>
<pre><code class="language-c">P.x = 10; P.y = 45;
</code></pre>
<p>Erlang 没有类型声明，因此要创建一个 “点”，我们可以这样写：</p>
<pre><code class="language-erlang">P = {10, 45}
</code></pre>
<p>这会创建出一个元组，并将其绑定到变量 <code>P</code>。与 C  的结构体不同，元组的字段没有名字。由于这个元组本身只包含两个整数，我们必须记住他的用途。为更容易记住元组的用途，常见使用原子作为元组第一个元素，描述这个元组所表示内容。因此，我们可以写下 <code>{point, 10, 45}</code>，而不是 <code>{10, 45}</code>，这就使得程序就更容易理解。这种标记元组的方式，并非一项语言的要求，而是一种推荐的编程风格。</p>
<p>元组可以嵌套。设想我们打算表示某人一些事实 -- 名字、身高、脚的大小和眼睛颜色。我们可以这样做：</p>
<pre><code class="language-erlang">2&gt; Person = {person, {name, joe}, {height, 1.82}, {footsize, 42}, {eyecolor, brown}}.
{person,{name,joe},
        {height,1.82},
        {footsize,42},
        {eyecolor,brown}}
</code></pre>
<blockquote>
<p><strong>译注</strong>：上面的行也可以写为：</p>
</blockquote>
<pre><code class="language-erlang">4&gt; Person = {person, {name, joe}, {height, 1.82},
   {footsize, 42}, {eyecolor, brown}}.
{person,{name,joe},
        {height,1.82},
        {footsize,42},
        {eyecolor,brown}}
</code></pre>
<p>请注意我们如何使用原子标识字段，以及（在 <code>name</code> 和 <code>eyecolor</code> 的情况下）为字段赋值。</p>
<h3 id="创建元组"><a class="header" href="#创建元组">创建元组</a></h3>
<p>元组在我们声明他们时，自动创建出来，并在他们无法继续使用时销毁。</p>
<p>Erlang 使用垃圾回收器，回收所有未使用的内存，因此我们不必担心内存分配问题。</p>
<p>若我们在构建某个新元组时，使用了某个变量，那么这个新元组将共享由该变量引用的数据结构值。下面是个示例：</p>
<pre><code class="language-erlang">1&gt; F = {firstname, joe}.
{firstname,joe}
2&gt; L = {lastname, armstrong}.
{lastname,armstrong}
3&gt; P = {person, F, L}.
{person,{firstname,joe},{lastname,armstrong}}
</code></pre>
<p>若我们试图创建一个带有未定义变量的数据结构，那么我们将得到一个报错。</p>
<pre><code class="language-erlang">1&gt; {true, Q, 23, Costs}.
* 1:8: variable 'Q' is unbound
</code></pre>
<blockquote>
<p><strong>译注</strong>：原文为：</p>
</blockquote>
<pre><code class="language-erlang">5&gt; {true, Q, 23, Costs}.
** 1: variable 'Q' is unbound **
</code></pre>
<blockquote>
<p>可见新版本的 Erlang/OTP 中，报错信息有改变和优化，精确到了行号与在行内的位置。</p>
</blockquote>
<p>这意味着变量 <code>Q</code> 未定义。</p>
<h3 id="提取元组中的值"><a class="header" href="#提取元组中的值">提取元组中的值</a></h3>
<p>早先我们曾说过，看起来像赋值语句的 <code>=</code> 其实不是个赋值语句，而是个模式匹配运算符。咱们可能想知道我们为什么要这么迂腐。事实证明，模式匹配是 Erlang 的基础，被用于许多不同的任务。他被用于从数据结构中提取值，也被用于函数内部的控制流，还用于并行程序中,当我们将消息发往某个进程时，选取要处理的消息。</p>
<p>在我们打算提取元组中某些值时，我们就可以使用模式匹配运算符 <code>=</code>。</p>
<p>咱们来回到咱们表示某个点的元组。</p>
<pre><code class="language-erlang">1&gt; Point = {point, 10, 45}.
{point,10,45}
</code></pre>
<p>设想我们打算把 <code>Point</code> 的字段，提取到 <code>X</code> 和 <code>Y</code> 两个变量中，我们会像下面这样完成：</p>
<pre><code class="language-erlang">2&gt; {point, X, Y} = Point.
{point,10,45}
3&gt; X.
10
4&gt; Y.
45
</code></pre>
<p>在命令 2 中，<code>X</code> 会被绑定为 <code>10</code>，<code>Y</code> 会被绑定为 <code>45</code>。表达式 <code>Lhs = Rhs</code> 的值会被定义为 <code>Rhs</code>，因此 shell 会打印 <code>{point,10,45}</code>。</p>
<p>正如咱们所见，等号两侧的元组，必须有着同样数量的元素，且两侧的对应元素必须绑定到同一值。</p>
<p>现在设想我们输入了这样的东西：</p>
<pre><code class="language-erlang">5&gt; {point, C, C} = Point.
** exception error: no match of right hand side value {point,10,45}
</code></pre>
<p>模式 <code>{point, C, C}</code> 不与 <code>{point, 10, 45}</code> 匹配，因为 <code>C</code> 不可能同时是 <code>10</code> 和 <code>45</code>。因此，这个模式匹配会失败，系统就打印了一条报错消息。</p>
<p>下面是个其中模式 <code>{point, C, C}</code> 确实匹配的示例：</p>
<pre><code class="language-erlang">6&gt; Point1 = {point, 25, 25}.
{point,25,25}
7&gt; {point, C, C} = Point1.
{point,25,25}
8&gt; C.
25
</code></pre>
<p>若我们有一个复杂的元组，那么我们可以通过编写一个与该元组形状（结构）相同，且在我们想要提取值处包含着未绑定变量的模式，提取该元组中的值。</p>
<p>为说明这点，我们将首先定义一个包含了复杂数据结构的变量 <code>Person</code>。</p>
<pre><code class="language-erlang">1&gt; Person = {person, {name, joe, armstrong}, {footsize, 42}}.
{person,{name,joe,armstrong},{footsize,42}}
</code></pre>
<p>现在我们将编写一个提取此人名字的模式。</p>
<pre><code class="language-erlang">2&gt; {_, {_, Who, _}, _} = Person.
{person,{name,joe,armstrong},{footsize,42}}
</code></pre>
<p>最后我们将看看 <code>Who</code> 的值。</p>
<pre><code class="language-erlang">3&gt; Who.
joe
</code></pre>
<p>请注意在前面这个示例中，我们把 <code>_</code> 写作了我们不感兴趣变量的占位符。符号 <code>_</code> 被称为 <em>匿名变量</em>。与常规变量不同，在同一模式中多次出现的 <code>_</code>，不必绑定到同一个值。</p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<p>列表被用于存储任意数量的东西。通过将列表元素括在一对方括号中，并用逗号分隔他们，我们创建出一个列表。</p>
<p>设想我们打算表示一幅图画。若我们假定这幅图是由三角形和正方形组成，那么我们就将这幅图表示为一个列表。</p>
<pre><code class="language-erlang">1&gt; Drawing = [{square, {10, 10}, 10}, {triangle, {15,10}, {25,10}, {30,40}}].
[{square,{10,10},10},{triangle,{15,10},{25,10},{30,40}}]
</code></pre>
<p>这个绘图列表中的每个元素，都是一些固定大小的元组（比如，<code>{square, Point, Side}</code> 或 <code>{triange, Point1, Point2, Point3}</code>），但绘图本身,则可包含任意数量的事物，因此就一个列表来表示。</p>
<p>某个列表的单个元素，可以是任何类型，因此，比如我们就可以写出以下代码：</p>
<pre><code class="language-erlang">2&gt; [1+7, hello, 2-2, {cost, apple, 30-20}, 3].
[8,hello,0,{cost,apple,10},3]
</code></pre>
<h3 id="术语"><a class="header" href="#术语">术语</a></h3>
<p>我们把列表中的首个元素，称为该列表的 <em>头</em>。若咱们设想把列表的头去掉，那么剩下的就叫做列表的 <em>尾巴</em>。</p>
<p>比如，若我们有个列表 <code>[1,2,3,4,5]</code>，那么这个列表的头就是整数 <code>1</code>，而尾巴就是列表 <code>[2,3,4,5]</code>。请注意，某个列表的头可以是任何东西，但某列表的尾巴，通常也是个列表。</p>
<p>访问某列表的头，是种非常高效的操作，因此几乎所有列表处理函数，都是从提取列表头开始，对该列表头进行处理，然后再处理列表尾巴。</p>
<h3 id="定义列表"><a class="header" href="#定义列表">定义列表</a></h3>
<p>当 <code>T</code> 是个列表时，那么 <code>[H|T]</code> 也是个头为 <code>H</code>、尾巴为 <code>T</code> 的列表。其中竖线（<code>|</code>）把列表的头与其尾巴分开。 <code>[]</code> 则是个空列表。</p>
<p><em>LISP 程序员注意</em>：<code>[H|T]</code> 是个有着 CAR <code>H</code> 和 CDR <code>T</code> 的 CONS 单元。在某个模式中，这种语法会解包出 CAR 与 CDR。而在某个表达式中，其会构造出一个 CONS 单元。</p>
<p>每当我们使用 <code>[...|T]</code> 构造器，构造某个列表时，都应确保 <code>T</code> 是个列表。当其是个列表时，那么新列表将是 “良好格式的”。而若 <code>T</code> 不是个列表，那么新列表就被说成是个 “不良列表”。大多数库函数都假定了列表是良好格式的，进而对于不良列表不会工作。</p>
<p><em>知识点</em>：</p>
<ul>
<li>unpacks the CAR and CDR</li>
<li>properly formed list</li>
<li>improper list</li>
</ul>
<p>通过写下 <code>[E1,E2,...,En|T]</code>，我们就可将多个元素，添加到 <code>T</code> 的开头。</p>
<p>因此，比如当我们一开始如下定义了 <code>ThingsToBuy</code> 时：</p>
<pre><code class="language-erlang">3&gt; ThingsToBuy = [{apples, 10}, {pears, 6}, {milk, 3}].
[{apples,10},{pears,6},{milk,3}]
</code></pre>
<p>随后我们就可以通过写下如下代码，扩展这个列表：</p>
<pre><code class="language-erlang">4&gt; ThingsToBuy1 = [{oranges, 4}, {newspaper, 1}|ThingsToBuy].
[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]
</code></pre>
<h3 id="提取列表中的元素"><a class="header" href="#提取列表中的元素">提取列表中的元素</a></h3>
<p>与其他操作一样，我们可通过模式匹配操作，提取出某个列表中的元素。当我们有个非空列表 <code>L</code> 时，那么表达式 <code>[X|Y] = L</code>，其中 <code>X</code> 和 <code>Y</code> 是非绑定变量，将把该列表的头提取到 <code>X</code> 中，把该列表的尾巴提取到 <code>Y</code> 中。</p>
<p>因此，设想我们在商店里，并且我们有着咱们的购物清单 <code>ThingsToBuy1</code> -- 那么我们做的第一件事，就是把这个清单拆开为其首尾两部分。</p>
<pre><code class="language-erlang">5&gt; [Buy1|ThingsToBuy2] = ThingsToBuy1.
[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]
</code></pre>
<p>此命令会以绑定 <code>Buy1 = {oranges,4}</code> 及 <code>ThingsToBuy2 = [{newspaper,1}, {apples,10}, {pears,6}, {milk,3}]</code> 成功。我们去买橘子，然后就可以提取接下来的几个项目。</p>
<pre><code class="language-erlang">6&gt; [Buy2, Buy3|ThingsToBuy3] = ThingsToBuy2.
[{newspaper,1},{apples,10},{pears,6},{milk,3}]
</code></pre>
<p>此命令会以绑定 <code>Buy2 = {newspaper, 1}</code>、<code>Buy3 = {apples, 10}</code> 及 <code>ThingsToBuy3 = [{pears, 6}, {milk, 3}]</code> 成功执行。</p>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>严格来说，Erlang 中没有字符串。要表示一个 Erlang 中的字符串，我们可选择将字符串表示为一个整数列表，或一个二进制值（有关二进制的讨论，请参见 <a href="Ch07-binaries_and_the_bit_syntax.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%80%BC">7.1 小 节，二进制</a>）。当某个字符串被表示为整数列表时，则该列表中的每个元素，都表示一个 Unicode 编码点。</p>
<p>我们可通过使用字符串字面值，创建出这样一个列表。所谓 <em>字符串字面值</em>，只是个以双引号（<code>"</code>）括起来的字符序列，例如，我们可以这样写：</p>
<pre><code class="language-erlang">1&gt; Name = "Hello".
"Hello"
2&gt; Hello = "你好".
[20320,22909]
</code></pre>
<blockquote>
<p><strong>译注</strong>：shell 之所以无法直接打印出 <code>"你好"</code> 字符串，是因为 <code>20320</code> 不是可打印的 Latin1 字符编码。</p>
</blockquote>
<p><code>"Hello"</code> 只是代表该字符串中各个字符整数字符代码列表的简称。</p>
<p><em>请注意</em>：在某些编程语言中，字符串既可以单引号，也可以双引号括起来。而在 Erlang 中，我们必须使用双引号。</p>
<p>在 shell 打印某个列表的值时，若该列表中的所有整数都表示了可打印字符，则会以字符串字面值形式打印；否则，他会以列表写法形式打印（有关字符集的问题，请参见 <a href="Ch08-the_rest_of_sequential_erlang.html#%E5%AD%97%E7%AC%A6%E9%9B%86">8.8 小节，字符集</a>）。</p>
<pre><code class="language-erlang">3&gt; [1,2,3].
[1,2,3]
4&gt; [83,117,114,112,114,105,115,101].
"Surprise"
5&gt; [1,83,117,114,112,114,105,115,101].
[1,83,117,114,112,114,105,115,101]
</code></pre>
<p>在表达式 3 中，列表 <code>[1,2,3]</code> 在未转换下就被打印了。这是因为 <code>1</code>、<code>2</code> 和 <code>3</code> 均不是可打印字符。</p>
<p>在表达式 4 中，该列表中所有项目都是可打印字符，因此该列表打印被打印为一个字符串字面值。</p>
<p>表达式 5 与表达式 4 类似，只是该列表以 <code>1</code> 开头，而 <code>1</code> 不是个可打印字符。因此，该列表在未转换下即被打印。</p>
<p>我们无需知道哪个整数代表某个特定字符。我们可使用 “美元符语法” 达到此目的。例如，<code>$a</code> 实际上就是代表字符 <code>a</code> 的整数，以此类推。</p>
<pre><code class="language-erlang">6&gt; I = $s.
115
7&gt; [I-32, $u, $r, $p, $r, $i, $s, $e].
"Surprise"
</code></pre>
<p>在我们使用列表表示字符串时，列表中的单个整数表示 Unicode 字符。我们必须使用特殊语法，输入某些字符，并在我们打印该列表时，选取正确的格式约定。最好用个示例解释这一点。</p>
<pre><code class="language-erlang">1&gt; X = "a\x{221e}b".
[97,8734,98]
2&gt; io:format("~ts~n",[X]).
a∞b
</code></pre>
<p>在第 1 行中，我们创建了三个整数的一个列表。第一个整数 <code>97</code> 是字符 <code>a</code> 的 ASCII 和 Unicode 编码。<code>\x{221e}</code> 写法用于 输入十六进制整数（<code>8734</code>），表示 Unicode 的 INFINITY （无穷大）字符。最后，<code>98</code> 是字符 <code>b</code> 的 ASCII 和 Unicode 编码。shell 会以列表记法打印这个列表（<code>[97,8734,98]</code>）；这是因为 <code>8734</code> 不是个可打印的 Latin1 字符编码。在第 2 行中，我们使用了个格式化 I/O 语句，以使用这个无穷大字符的正确字符字形，打印出该字符串。</p>
<blockquote>
<p><strong>译注</strong>：以这种方式，我们可以打印出上面 UTF-8 编码的汉字 <code>"你好"</code> 字符串字面值。</p>
</blockquote>
<pre><code class="language-erlang">8&gt; io:format("~ts~n", [Hello]).
你好
ok
</code></pre>
<p>若 shell 将某个整数列表打印为字符串，而咱们确实希望他被打印为整数列表，那么咱们就必须使用一个格式化的写入语句，如下所示：</p>
<pre><code class="language-erlang">1&gt; X = [97,98,99].
"abc"
2&gt; io:format("~w~n", ["abc"]).
[97,98,99]
ok
</code></pre>
<p><em>知识点</em>：</p>
<ul>
<li>a formatted I/O statement</li>
<li>a formatted write statement</li>
</ul>
<h2 id="又来模式匹配"><a class="header" href="#又来模式匹配">又来模式匹配</a></h2>
<p>在本章的最后，我们再来看一次模式匹配。</p>
<p>下表列出了一些模式及术语的示例；这些模式中的所有变量，都假定为未绑定的。所谓 <em>项目</em>，只是某个 Erlang 的数据结构。表中标为 <em>结果</em> 的第三列，显示了模式是否与该项目匹配，在匹配时，变量绑定就会被创建出来。请通读这些示例，确保咱们真正理解他们。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><em>模式</em></th><th style="text-align: center"><code>=</code></th><th style="text-align: left"><em>项目</em></th><th style="text-align: left"><em>结果</em></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>{X,adb}</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>{123,abc}</code></td><td style="text-align: left">以 <code>X = 123</code> <em>成功</em></td></tr>
<tr><td style="text-align: left"><code>{X,Y,Z}</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>{222,def,"cat"}</code></td><td style="text-align: left">以 <code>X = 123</code>、<code>Y = def</code> 及 <code>Z = "cat"</code> <em>成功</em></td></tr>
<tr><td style="text-align: left"><code>{X,Y}</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>{333, ghi, "cat"}</code></td><td style="text-align: left"><em>失败</em> -- 两个元组形状不同</td></tr>
<tr><td style="text-align: left"><code>X</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>true</code></td><td style="text-align: left">以 <code>X = true</code> 成功</td></tr>
<tr><td style="text-align: left"><code>{X,Y,X}</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>{{abc,12},42,{abc,12}}</code></td><td style="text-align: left">以 <code>X = {abc,12}</code> 及 <code>Y = 42</code> 成功</td></tr>
<tr><td style="text-align: left"><code>{X,Y,X}</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>{{abc,12},42,true}</code></td><td style="text-align: left"><em>失败</em> -- <code>X</code> 无法同时与 <code>{abc,12}</code> 和 <code>true</code> 匹配</td></tr>
<tr><td style="text-align: left"><code>[H|T]</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>[1,2,3,4,5]</code></td><td style="text-align: left">以 <code>H = 1</code> 及 <code>T = [2,3,4,5]</code> 成功</td></tr>
<tr><td style="text-align: left"><code>[H|T]</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>"cat"</code></td><td style="text-align: left">以 <code>H = 99</code> 及 <code>T = "at"</code> 成功</td></tr>
<tr><td style="text-align: left"><code>[A,B,C|T]</code></td><td style="text-align: center"><code>=</code></td><td style="text-align: left"><code>[a,b,c,d,e,f]</code></td><td style="text-align: left">以 <code>A = a</code>、<code>B = b</code>、<code>C = c</code> 及 <code>T = [d,e,f]</code> 成功</td></tr>
</tbody></table>
</div>
<p>若咱们对这其中任何一个不确定，那么可尝试在 shell 中输入 <code>Pattern = Term</code> 表达式，看看会发生什么。</p>
<p>以下是个示例：</p>
<pre><code class="language-erlang">1&gt; {X, abc} = {123, abc}.
{123,abc}
2&gt; X.
123
3&gt; f().
ok
4&gt; {X,Y,Z} = {222, def, "cat"}.
{222,def,"cat"}
5&gt; X.
222
6&gt; Y.
def
</code></pre>
<p><em>请注意</em>：其中命令 <code>f()</code> 告诉 shell <em>忘掉</em> 他所有的绑定。在该命令后，所有变量都会成为未绑定的，因此第 4 行中的 <code>X</code>，与第 1 及第 2 行中的 <code>X</code> 毫无关系。</p>
<p>现在，我们已经熟悉了这些基本数据类型，以及单一赋值和模式匹配的概念。我们可以加快步伐，看看如何定义模组与函数。我们将在下一章中完成此事。</p>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ol>
<li>
<p>请快速浏览一下 <a href="#Erlang-shell-%E4%B8%AD%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BC%96%E8%BE%91">Erlang Shell 下的命令编辑</a>，然后测试并记住这些行编辑命令；</p>
</li>
<li>
<p>请在 shell 中输入 <code>help()</code> 命令。咱们将看到一个长的命令清单。请试试其中一些命令；</p>
</li>
<li>
<p>请尝试使用一个元组表示一座房屋，并使用房屋列表表示一条街道。请确保咱们可打包和解包这种表示中的数据。</p>
</li>
</ol>
<footer id="last-change">Last change: 2025-08-21, commit: <a href="https://github.com/gnu4cn/erlang-book/commit/ba5ef16">ba5ef16</a></footer>
            </main>

            <nav class="nav-wrapper" aria-label="Page navigation">
              <!-- Mobile navigation buttons -->
              <a rel="prev" href="../part-ii.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
              </a>

              <a rel="next" href="../part-ii/Ch04-modules_and_functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
              </a>

              <div style="clear: both"></div>
            </nav>
          </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
          <a rel="prev" href="../part-ii.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
            <i class="fa fa-angle-left"></i>
          </a>

          <a rel="next" href="../part-ii/Ch04-modules_and_functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
            <i class="fa fa-angle-right"></i>
          </a>
        </nav>

      </div>

      <!-- Livereload script (if served using the cli tool) -->
      <script>
        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
        const socket = new WebSocket(wsAddress);
        socket.onmessage = function (event) {
                  if (event.data === "reload") {
                            socket.close();
                            location.reload();
                          }
                };

        window.onbeforeunload = function() {
                  socket.close();
                }
      </script>


      <script>
        window.playground_copyable = true;
      </script>



      <script src="../clipboard.min.js"></script>
      <script src="../highlight.js"></script>
      <script src="../book.js"></script>

      <!-- Custom JS scripts -->
      <script src="../theme/pagetoc.js"></script>


    </div>

<!-- Donation dialog -->
<dialog class="modal">
  <p>小额打赏，赞助 xfoss.com 长存......</p>

<div class="slider">
  <a href="#slide-1">微信</a> |
  <a href="#slide-2">支付宝</a>

  <div class="slides">
    <div id="slide-1">
         <img src="../images/wechat-pay-hector.jpeg" />
    </div>
    <div id="slide-2">
          <img src="../images/alipay-laxers.jpeg" />
    </div>
  </div>
</div>

<br />
  <p>若这里内容有帮助到你，请选择上述方式向 xfoss.com 捐赠。</p>
  <button class="close-button">Close</button>
</dialog>



  </body>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-V49YMMPZJN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-V49YMMPZJN');
</script>

<script>

const modal = document.querySelector('.modal');
const openButton = document.querySelector('.open-button');
const closeButton = document.querySelector('.close-button');

openButton.addEventListener('click', () => {
  modal.showModal();
});

closeButton.addEventListener('click', () => {
  modal.close();
});
</script>
    <style type="text/css">
button {
  display: inline-block;
  margin: 5px auto;
  border: 0;
  border-radius: 2px;
  padding: 3px 8px;
  font-family: Arial, Helvetica, sans-serif;
  font-size: 14px;
  font-weight: 600;
    background-color: #FFA12B;
  cursor: pointer;
  color: #FFF;
  transition: all 240ms linear;
}

button:hover {
  filter: brightness(0.8);
}
button:active {
  transform: scale(0.9);
}
dialog {
  margin: 10% auto;
  width: 80%;
  max-width: 800px;
  background-color: #eee;
  padding: 24px;
  border: 0;
  border-radius: 5px;
}
dialog > p {
  text-align: center;
  margin: 0;
}
dialog > p:first-of-type {
  margin: 0 auto 20px;
  font-size: 24px;
  font-weight: 600;
}
dialog > button {
    display: block;
    float: right;
}

* {
  box-sizing: border-box;
}

.slider {
  width: 300px;
  text-align: center;
  overflow: hidden;
  margin: 0 auto;
}

.slides {
  display: flex;

  overflow-x: auto;
  scroll-snap-type: x mandatory;



  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;

  /*
  scroll-snap-points-x: repeat(300px);
  scroll-snap-type: mandatory;
  */
}
.slides::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
.slides::-webkit-scrollbar-thumb {
  background: black;
  border-radius: 10px;
}
.slides::-webkit-scrollbar-track {
  background: transparent;
}
.slides > div {
  scroll-snap-align: start;
  flex-shrink: 0;
  width: 300px;
  height: 300px;
  margin-right: 50px;
  border-radius: 10px;
  background: #eee;
  transform-origin: center center;
  transform: scale(1);
  transition: transform 0.5s;
  position: relative;

  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 100px;
}
.slides > div:target {
/*   transform: scale(0.8); */
}
.author-info {
  background: rgba(0, 0, 0, 0.75);
  color: white;
  padding: 0.75rem;
  text-align: center;
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  margin: 0;
}
.author-info a {
  color: white;
}
.slides > div > img {
  object-fit: cover;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slider > a {
  display: inline-flex;
  height: 1.5rem;
  background: white;
  text-decoration: none;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  margin: 0 0 0.5rem 0;
  position: relative;
}
.slider > a:active {
  top: 1px;
}
.slider > a:focus {
  background: #000;
}

/* Don't need button navigation */
@supports (scroll-snap-type) {
  .slider > a {
    display: none;
  }
}

    </style>

</html>
