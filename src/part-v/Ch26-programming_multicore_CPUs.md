# 多核 CPU 编程

![现代 CPU](../images/CPU.png)

*我们怎样编写在多核心 CPU 上运行更快的程序呢？这一切都与可变状态和并发有关*。

在过去（二十多年前），有两种并发模型。

- 共享状态的并发
- 消息传递的并发

编程界走了一条路（朝着共享状态）。Erlang 社区则走的是另一条路。(很少有其他语言循着 “消息传递的并发” 这条道路；这些别的语言有 [Oz](https://en.wikipedia.org/wiki/Oz_(programming_language)) 及 [Occam](https://en.wikipedia.org/wiki/Occam_(programming_language))）。


在消息传递的并发下，是没有共享状态的。所有计算在进程中完成，交换数据的 *唯一* 方式，是经由异步的消息传递。

*为何这很不错*？

共享状态的并发，涉及 “可变状态”（可被更改的内存）的这一概念 -- 诸如如 C、Java、C++ 等所有语言，都有着这种概念：有一种叫 *状态* 的东西，而我们可以改变他。

在咱们只有 *一个* 进程进行更改时，这不会有问题。


当咱们有正共用并修改 *同一* 内存的多个进程时，咱们就会后患无穷 -- 疯狂就在这里。

> **知识点**：
>
> [a receipe for disaster, 后患无穷](https://www.bbc.co.uk/learningenglish/chinese/features/authentic-real-english/ep-160405)

要防止共享内存的同时修改，我们就要使用某种加锁机制。咱们可以把这叫做互斥锁、同步方法或其他任何东西，但他仍是把锁。

当程序在临界区（当其持有锁）崩溃时，就会导致灾难。所有其他程序都不知道要做什么。当程序破坏了处于共享状态的内存时，灾难也将发生。其他程序将不知道要做什么。


程序员怎么解决这些问题呢？困难重重。在单核处理器上，他们的程序可能恰好工作了 -- 但在多核处理器上......就是灾难。

对此，有一些不同解决方案（事务内存可能是最好的），但这些充其量也就是些 “蹩脚货”。最糟糕的是，它们简直就是噩梦。

*Erlang 没有可变数据结构*（这也不全对，但也足够正确）。

- 没有可变数据结构 == 没有锁；
- 没有可变数据结构 == 易于并行化。

我们怎么做到并行化？很简单。程序员会把问题解法，分解成若干并行进程。

这种编程风格有自己的术语；他被叫做 *面向并发的编程*。




## 并行序列代码

