# 接口技术

系统的构建，经常涉及将以不同编程语言编写的应用，与咱们的系统连接起来。我们可能将 C 用于提高效率，或编写底层的硬件驱动，抑或我们可能打算集成某个以 Java、Ruby 或其他编程语言编写的库。我们可以数种方式，将一些外语程序与 Erlang 连接起来。


- 通过在某个外部操作系统进程中，在 Erlang 虚拟机 *外部* 运行程序。这是一种 *安全的* 方法。当外部语言的代码不正确时，也不会导致 Erlang 系统崩溃。Erlang 通过称为一种称作 *端口* 的设备，控制外部进程，并经由面向字节的通信信道，与外部进程通信。Erlang 负责启动及停止外部程序，并可监控他们，当其崩溃时重启他们。这些外部进程，被称为 *端口进程*，因为其是通过某个 Erlang 端口控制的；

- 在 Erlang 中运行某个操作系统命令，并捕获结果；

- 在 Erlang 虚拟机 *内部* 运行其他语言的代码。这涉及将外部代码，与 Erlang 虚拟机的代码链接起来。这是一种 *不安全的* 方法。其他语言代码中的错误，可能会导致 Erlang 系统崩溃。虽然这种方法不安全，但却很有用，因为相比使用外部进程，他更有效率。

    将其他语言代码链接进到 Erlang 内核，只能用于 C 等生成原生对象代码的那些语言，而不能用于 Java 等有其自己虚拟机的那些语言。

在本章中，我们将学习使用端口和操作系统命令，连接 Erlang。此外，还有一些使用链接驱动、原生实现函数（NIFs）及 C 节点等高级接口技术。这些高级技术未在本书中涉及，但在本章末尾，我们将简要介绍这些技术，并提供一些参考资料。

> *知识点*：
>
> - linked-in drivers
>
> - natively implemented functions, NIFs
>
> - C-nodes


## Erlang 如何与外部程序通信


Erlang 通过名为 *端口* 的对象，与外部程序通信。当我们将一条消息发送给某个端口时，该消息将被发送到与该端口相连的外部程序。而来自外部程序的消息，将呈现为来自端口的 Erlang 消息。


就程序员而言，端口的行事方式，与 Erlang 进程无异。咱们可将消息发送给他，咱们可将其注册（就像进程一样），等等。当外部程序崩溃时，那么一个退出信号，将发送到所连接的进程，而当连接的进程死亡时，则对应外部程序也会被杀死。


请注意使用端口与外部进程通信，与使用套接字与外部程序通信的区别。当咱们使用端口时，端口将以 Erlang 进程方式行事，因此咱们可以链接到他，从远端的分布式 Erlang 节点发送消息给他等等。而当咱们使用套接字时，其将不会以进程方式行事。


创建了端口的进程，称为该端口的 *连接进程*。连接进程具有显著意义：所有发送到该端口的消息，都必须以连接进程的 PID 标记，同时所有来自外部程序的消息，都会发送到这个连接进程。


我们可以在下图中，看到连接进程（C）、端口（P）与外部操作系统进程间的关系：

![Erlang 端口](../images/erlang_ports.png)

