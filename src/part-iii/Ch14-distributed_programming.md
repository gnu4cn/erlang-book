# 分布式编程


编写 Erlang 的分布式程序，只是编写并发程序中的一小步。在分布式的 Erlang 中，我们可在远端节点和机器上，生成进程。在生成了远端进程后，我们将看到所有其他原语，即 `send` 、`receive`、`link` 等，都可以像在单个节点上一样，经由网络透明地运行。


在这一章中，我们将引入我们用以编写分布式 Erlang 程序的库和原语。*分布式程序* 属于被设计在计算机网络上运行，并只能经由消息传递，协调其活动的程序。


下面是我们要编写分布式应用的一些原因：


- *性能*

    通过将程序的不同部分，分派在不同机器上并行运行，我们可以让程序运行得更快。

- *可靠性*

    经由将系统架构于多台机器上，我们可构造出容错系统。当一台机器失效时，我们可在另一机器上继续。

- *可扩展性*

    随着我们扩大某个应用规模，迟早我们都将耗尽机器性能，即使是最强大的机器。在这个阶段，我们就必添加更多的机器，以增加能力。添加新机器应是无需对应用架构大改动的简单操作。

- *内在分布式应用*

    许多应用内在就是分布式的。当我们编写某个多用户游戏，或聊天系统时，不同用户将分散在全球各地。当我们有用户集中在某一特定地理位置时，我们就会打算将计算资源，放在这些用户附近。

- *乐趣*

    我（作者）打算编写的大多数有趣程序，都是分布式的。其中许多都涉及与世界各地的人和机器交互。


### 分布式的两种模型


在本书中，我们将讨论分布式的两种主要模型。


- *分布式 Erlang*

    在分布式 Erlang 下，程序被编写为运行于 Erlang *节点*。所谓节点，是以其自己的地址空间与进程集，包含了完整虚拟机的独立 Erlang 系统。

    我们可在任何节点上生成进程，同时我们前几章中讲到的所有消息传递和错误处理原语，都可在这种单节点情形下工作。

    分布式 Erlang 的应用，运行在 *受信任* 环境中 -- 因为任何节点，都可在任何其他 Erlang 节点上，执行任何操作，这就涉及到一种高度信任。通常情况下，分布式 Erlang 应用，将运行在同一局域网的集群上，并在防火墙之后，尽管他们也可运行在开放网络中。

- *基于套接字的分布式*

    运用 TCP/IP 套接字，我们可编写出能在 *不受信任* 环境中，运行的分布式应用。与分布式 Erlang 相比，这种编程模型不那么强大，但更为安全。在 [14.6 小节 “基于套接字的并发”](基于套接字的并发) 中，我们将了解如何运用一种简单的基于套接字的并发机制构造应用。



当咱们回想前面的章节时，咱们就会记得，我们构建程序的基本单元，便是进程。编写分布式 Erlang 程序非常简单；我们只须在正确的机器上，生成咱们的进程，然后一切都会像以前一样运作。


我们都习惯于编写顺序程序。编写分布式程序通常要困难得多。在本章中，我们将学习编写简单分布式程序的一些技巧。尽管这些程序很简单，但却非常有用。


我们将从一些小的示例开始。为此，我们将只需掌握两件事；然后我们就可以构造我们的第一个分布式程序。我们将学习怎样启动一个 Erlang 节点，以及怎样在某个远程 Erlang 节点上，执行一次远程过程调用。


> *知识点*：
>
> - an Erlang node
>
> - a remote procedure call, a RPC


## 编写一个分布式程序


当开发某个分布式应用时，我（作者）总是以特定顺序，于该程序上开展工作，该顺序如下：


1. 我（作者）会在常规的非分布式 Erlang 会话中，编写和测试我的程序。这便是到目前为止，我们一直都在做的，所以这还没有表现出什么新挑战；

2. 我（作者）会在 *同一台计算机* 上，运行的两个不同 Erlang 节点中，测试我的程序；

3. 我（作者）会在运行在同一局域网内，或互联网上任何地方的 *两台物理分离的计算机* 上的两个不同 Erlang 节点上，测试我的程序。


最后一步可能会有问题。当我们在同一管理域内的机器上运行时，这很少会是个问题。但当所涉及节点属于不同域的机器时，我们就会遇到连接问题，同时我们必须确保我们的系统防火墙及安全设置配置正确。


为说明这些步骤，我们将构造一个简单的名字服务器。具体来说，我们将完成下面这些事情：


- 阶段 1：在常规非分布式 Erlang 系统下，编写并测试这个名字服务器；

- 阶段 2：在同一机器的两个节点上，测试这个名字服务器；

- 阶段 3：在同一局域网内的两台不同机器上的两个不同节点上，测试这个名字服务器；

- 阶段 4：在两个不同国家，分属两个不同域的两台不同机器上，测试这个名字服务器。



## 构建名字服务器


所谓 *名字服务器*，是个在给其一个名字后，返回一个与该名字关联值的程序。我们还可以修改与某个特定名字关联的值。


我们的首个名字服务器相当简单。他不是容错的，因此当其崩溃时，他存储的所有数据都将丢失。这个练习的重点，不是构造一个容错的名字服务器，而是分布式编程技术入门。


### 阶段 1：简单名字服务器

我们的名字服务器 `kvs`，是个简单的 `Key → Value` 服务器。他有着以下接口：


- `-spec kvs:start() -> true`

    启动该服务器；这会以注册名字 `kvs`，创建出一个服务器。

- `-spec kvs:store(Key, Value) -> true`

    将 `Key` 与 `Value` 关联。

- `-spec kvs:lookup(Key) -> {ok, Value} | undefined`


    查找 `Key` 的值，当存在某个与 `Key` 关联的值时，则返回 `{ok, Value}`；否则返回 `undefined`。


这个键值服务器，是使用进程字典的 `get` 与 `put` 原语实现的，如下所示：


```erlang
{{#include ../../projects/ch14-code/socket_dist/kvs.erl}}
```


存储消息于第 6 行出发送，并在第 19 行接收。主服务器于第 17 行的 `loop` 函数处启动；他调用了 `receive` 并等待一个存储或查找消息，然后将请求数据保存在本地进程字典，或从本地进程字典中检索请求数据，并将一个回复发送回客户端。我们将以在本地测试该服务器开始，看看他是否正常工作。


```erlang
1> kvs:start().
true
2> kvs:store({location, joe}, "Stockholm").
true
3> kvs:store(weather, raining).
true
4> kvs:lookup({location, joe}).
{ok,"Stockholm"}
5> kvs:lookup({location,jane}).
undefined
6> kvs:lookup(weather).
{ok,raining}
```


到目前为止，我们都没有遇到令人不快的惊喜。接下来是第 2 步。我们来分发这个应用。


### 阶段 2：客户端在一个节点，服务器在第二个节点，不过仍是同一主机


现在，我们将在 *同一* 计算机上，启动两个 Erlang 节点。要完成这一目的，我们需要打开两个终端窗口，并启动两个 Erlang 系统。


首先，我们启动一个终端 shell，并在这个 shell 中启动一个名为 `gandalf` 的分布式 Erlang 节点；然后，我们启动这个服务器：

```erlang
$ erl -sname gandalf
...
(gandalf@ZBT7RX-L1)1> kvs:start().
true
```


其中参数 `-sname gandalf` 表示 “在本地主机上启动一个名字为 `gandalf` 的 Erlang 节点”。请注意 Erlang shell 在命令提示符前，打印 Erlang 节点名字的方式。节点名称的形式为 `Name@Host`。其中 `Name` 和 `Host` 均为原子，因此当他们包含任何非原子字符时，都必须加上引号。


*重要提示*：当咱们在自己系统上运行上面的命令时，节点名字可能不是 `gandolf@localhost`。他可能是 `gandolf@H`，其中 `H` 是咱们的本地主机名。这将取决于咱们的系统配置方式。当属于这种情形时，那么在后面的示例中，咱们都必须使用 `H` 而不是 `localhost`。


接下来我们就要启动 *第二个* 终端会话，并启动一个名为 `bilbo` 的 Erlang 节点。然后我们就可以使用库模组 `rpc`，调用 `kvs` 中的那些函数。（请注意，`rpc` 是个标准的 Erlang 库模组，其与我们先前编写的 `rpc` 函数不一样。）


```erlang
$ erl -sname bilbo
...
(bilbo@test)1> rpc:call(gandalf@test, kvs, store, [weather, fine]).
true
(bilbo@test)2> rpc:call(gandalf@test, kvs, lookup, [weather]).
{ok,fine}
```

现在可能看起来还不像回事，但我们实际上已经进行了咱们从未有过的第一次分布式计算！服务器运行在我们启动的第一个节点上，同时客户端运行在第二个节点上。


那个设置 `weather` 值的调用，是在 `bilbo` 节点上构造出的；我们可以换回 `gandalf` 节点，并检查天气的值。


```erlang
(gandalf@test)6> kvs:lookup(weather).
{ok,fine}
```


`rpc:call(Node,Mod,Func,[Arg1,Arg2,...,ArgN])` 会在 `Node` 上，执行一次 *远程过程调用*。被调用的函数为 `Mod:Func(Arg1,Arg2,...,ArgN)`。


正如我们所看到的，这个程序会如同非分布式 Erlang 情形下一样工作；现在唯一区别，是客户端运行在一个节点上，同时服务器运行在另一节点上。


下一步是要在不同的机器上，运行客户端与服务器。


### 阶段 3：同一局域网内不同机器上的客户端和服务器


我们将用到两个节点。第一个节点名为 `gandalf`，位于 `doris.myerl.example.com` 上，而第二个节点名为 `bilbo`，位于 `george.myerl.example.com` 上。在我们这样做前，我们要先在两台不同的机器上，使用 `ssh` 或 VNC 等工具启动两个终端。我们将这两个窗口，分别称为 `doris` 和 `george`。在完成后，我们就可以轻松地这两台机器上输入命令。


步骤 1 是在 `doris` 上启动一个 Erlang 节点。


```erlang
```


### 阶段 4：互联网中不同主机上的客户端与服务器


原则上，这与阶段 3 中的情况相同，但现在我们必须更为关注安全。当我们在同一局域网上运行两个节点时，我们可能不必太担心安全。在大多数组织中，局域网都经由防火墙与互联网隔离。在防火墙之后，我们可以随意以某种草率方式分配 IP 地址，而常常会错误配置机器。


当我们在互联网上，连接某个 Erlang 集群中的数台机器时，我们可能会遇到防火墙不放行传入连接的一些问题。我们将必须将我们的防火墙，配置为接受传入连接。由于每个防火墙都不同，因此没有某种通用的方式完成这点。


要准备将咱们的系统用于分布式 Erlang，咱们将必须采取以下步骤：

1. 确保端口 `4369` 同时对 TCP 和 UDP 流量开放。这个端口会被名为 `epmd`（Erlang Port Mapper Daemon 的缩写）的程序用到；

2. 要选取将用于分布式 Erlang 的某个端口，或某个端口范围，并确保这些端口是放开的。当这些端口是 `Min` 和 `Max`（当咱们只想打算一个端口时，则使用 `Min = Max`）时，则要以下面的命令，启动 Erlang：
    
    ```erlang
    $erl -name ... -setcookie ... -kernel inet_dist_listen_min Min \
                                          inet_dist_listen_max Max
    ```

现在我们已经了解了，如何在 Erlang 节点集上运行程序，以及如何在同一局域网，或经由互联网运行程序。接下来，我们将了解涉及节点的一些原语。
