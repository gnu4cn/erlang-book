# 使用 OTP 构造系统

在这一章中，我们将要构造一个可作为一家基于 web 的公司后端的系统。咱们的公司有两个产品销售：质数和面积。客户可以在我们这儿购买一个质数，我们也将提供计算某个几何对象面积的服务。我（作者）认为我们的公司潜力巨大。

我们将建立两个服务器：一个生成质数，另一个计算面积。要完成这点，我们将使用我们曾在 [22.2 小节 *`gen_server` 入门](Ch22-introducing_otp.md#gen_server-入门) 中讨论的 `gen_server` 框架。

在我们构建这个系统时，我们必须要考虑错误。即使我们已全面测试了我们的软件，我们可能也未曾捕捉到所有 bugs。我们将假设咱们的一个服务器有着会崩溃掉服务器的致命错误。事实上，我们将引入一个将导致服务器崩溃的 *故意错误* 到咱们的一个服务器中。

当该服务器崩溃时，我们将需要某种检测其已崩溃并重启他的机制。为此，我们将运用 *监督树* 的概念。我们将创建一个监控我们服务器，并在服务器崩溃时重启他们的监控器进程。


当然，当某个服务器崩溃时，我们将希望知道其崩溃的原因，从而我们可在稍后解决该问题。为记录所有错误，我们将使用 OTP 的错误记录器。我们将展示怎样配置这个错误日志记录器，以及如何从错误日志生成错误报告。

当我们计算质数，特别是大质数时，咱们的 CPU 可能会过热。为了防止这种情况，我们将需要打开大功率风扇。要这样做，我们将需要考虑 *警报*。我们将使用 OTP 的事件处理框架，生成及处理警报。


所有这些话题（创建服务器、监控服务器、错误记录及检测警报），都是任何生产系统中，都必须解决的几个典型问题。因此，尽管我们的公司可能有相当不确定的未来，但我们可以在许多系统中，重用这里的架构。事实上，这种架构在数家商业成功的公司里 *确实* 使用着。


最后，当一切都工作了时，我们将把我们所有的代码，打包成一个 OTP *应用*。这是一种将与某个特定问题相关的所有内容，进行分组的专门方式，以便其可由 OTP 系统自身启动、停止与管理。

由于不同领域间存在许多循环依赖，因此这些材料的呈现顺序会略显棘手。错误日志只是事件管理的一个特例。警报则只是一些事件，同时错误日志记录器又是个受监督的进程，而进程监督器又可以调用错误日志记录器。

我（作者）将在此尝试强行采取某种顺序，并以某种有意义顺序，呈现这些主题。我们将完成以下事情：

1. 我们来看看通用事件处理器中，用到的一些概念；
2. 我们将看到错误日志记录器的工作原理；
3. 我们将增加警报管理功能；
4. 我们将编写两个应用服务器；
5. 我们将构造一棵监管树，并将服务器添加到其上；
6. 我们将把所有内容打包成一个应用。


## 通用事件处理

所谓 *事件*，是指发生的事情 -- 程序员认为，有人应该对此做点什么的某种值得注意的事情。

当我们编程时，而某件值得注意的事情发生了，我们就要将一条 `event` 消息，发送到某个注册进程，就像这样：

```erlang
RegProcName ! {event, E}
```

其中 `E` 便是那个事件（任何的 Erlang 项）。`RegProcName` 是某个注册进程的名字。

我们不清楚（也不关心）我们发送了这条消息后会发生什么。我们已经完成了我们的工作，告诉了别人某事已发生。


现在我们来把注意力，转向接收事件消息的进程。这便是所谓的 *事件处理器*。最简单的事件处理器，是个 “什么都不做” 的处理器。当他收到 `{event, X}` 消息时，他对该事件什么都不做；他只将其丢弃。


下面是我们在某个通用事件处理器上的首次尝试：


```erlang
{{#include ../../projects/ch23-code/event_handler.erl}}
```


## 错误记录器

## 监督树

## 应用程序
